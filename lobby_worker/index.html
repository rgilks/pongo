<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong</title>
    <style>
        * { box-sizing: border-box; }
        body { 
            margin: 0; 
            padding: 10px; 
            min-height: 100vh; 
            background: #000; 
            color: #fff; 
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
        }
        
        #mainContainer {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            justify-content: center;
            gap: 20px;
            flex: 1;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }
        
        #gameContainer { 
            display: flex; 
            flex-direction: column; 
            align-items: center;
            flex: 0 0 auto;
        }
        
        #canvas { 
            border: 2px solid #fff; 
            display: block; 
            max-width: 100%;
            touch-action: none; /* Prevent scrolling on touch */
        }
        
        #sidePanel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 200px;
            flex: 0 0 auto;
        }
        
        #score { 
            font-size: 36px; 
            color: #fff; 
            text-shadow: 0 0 10px #fff; 
            margin: 0;
            text-align: center;
            font-weight: bold;
        }
        
        #metrics { 
            font-size: 13px; 
            color: #fff; 
            text-shadow: 0 0 5px #fff; 
            background: rgba(0, 0, 0, 0.7); 
            padding: 8px 12px; 
            border-radius: 4px; 
            font-family: 'Courier New', monospace; 
            border: 1px solid rgba(255, 255, 255, 0.2); 
            margin: 0;
        }
        
        .metric-row { 
            display: flex; 
            align-items: center; 
            margin: 4px 0; 
            white-space: nowrap; 
        }
        
        .metric-label { 
            color: #aaa; 
            margin-right: 8px; 
            min-width: 50px; 
        }
        
        .metric-value { 
            font-weight: bold; 
            color: #0f0; 
            min-width: 50px; 
            text-align: right; 
            margin-right: 4px; 
        }
        
        .metric-unit { 
            color: #888; 
            font-size: 11px; 
        }
        
        #ui { 
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        #status { 
            padding: 10px 20px; 
            background: #222; 
            border: 2px solid #fff; 
            border-radius: 4px; 
            font-size: 16px;
            margin: 0;
        }
        
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        input, button { 
            padding: 10px 20px; 
            margin: 0;
            font-family: 'Courier New', monospace; 
            font-size: 16px; 
            border: 2px solid #fff; 
            background: #000; 
            color: #fff;
            width: 100%;
        }
        
        button { 
            cursor: pointer; 
            transition: all 0.2s;
            touch-action: manipulation; /* Better touch response */
        }
        
        button:hover:not(:disabled) { 
            background: #fff; 
            color: #000; 
        }
        
        button:active:not(:disabled) {
            transform: scale(0.95);
        }
        
        button:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
        }
        
        .controls { 
            font-size: 14px; 
            color: #888;
            margin: 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        #matchCode { 
            text-transform: uppercase; 
        }
        
        /* Touch controls for mobile */
        #touchControls {
            display: none; /* Hidden by default, shown on mobile */
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 400px;
            padding: 0 20px;
            z-index: 1000;
        }
        
        .touch-button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            padding: 20px;
            font-size: 24px;
            color: #fff;
            text-align: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }
        
        .touch-button:active {
            background: rgba(255, 255, 255, 0.4);
        }
        
        .touch-controls-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        /* Mobile layout - stack vertically */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            #mainContainer {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            
            #sidePanel {
                width: 100%;
                max-width: 400px;
                order: 2; /* Show after canvas on mobile */
            }
            
            #gameContainer {
                order: 1; /* Show canvas first on mobile */
                width: 100%;
            }
            
            #canvas {
                width: 100%;
                max-width: 100vw;
                height: auto;
            }
            
            #touchControls {
                display: block;
            }
            
            .button-group {
                flex-direction: row;
                flex-wrap: wrap;
            }
            
            .button-group button {
                flex: 1;
                min-width: 100px;
            }
            
            #score {
                font-size: 28px;
            }
            
            #metrics {
                font-size: 12px;
            }
        }
        
        /* Very small screens */
        @media (max-width: 480px) {
            #score {
                font-size: 24px;
            }
            
            input, button {
                font-size: 14px;
                padding: 8px 16px;
            }
        }
    </style>
</head>
<body>
    <div id="mainContainer">
        <div id="gameContainer">
            <canvas id="canvas" width="640" height="480"></canvas>
        </div>
        <div id="sidePanel">
            <div id="score">0 : 0</div>
            <div id="metrics">
                <div class="metric-row"><span class="metric-label">FPS:</span><span class="metric-value" id="fps">--</span></div>
                <div class="metric-row"><span class="metric-label">Ping:</span><span class="metric-value" id="ping">--</span><span class="metric-unit">ms</span></div>
                <div class="metric-row"><span class="metric-label">Update:</span><span class="metric-value" id="update">--</span><span class="metric-unit">ms</span></div>
            </div>
            <div id="ui">
                <div id="status">Initializing...</div>
                <div class="button-group">
                    <input type="text" id="matchCode" placeholder="MATCH CODE" maxlength="5">
                    <button id="joinBtn">JOIN</button>
                    <button id="createBtn">CREATE</button>
                    <button id="localBtn">VS AI</button>
                </div>
                <div class="controls">
                    <strong>Controls:</strong><br>
                    Desktop: ‚Üë/‚Üì or W/S<br>
                    Mobile: Touch buttons below
                </div>
            </div>
        </div>
    </div>
    <!-- Touch controls for mobile -->
    <div id="touchControls">
        <div class="touch-controls-row">
            <div class="touch-button" id="touchUp">‚Üë UP</div>
            <div class="touch-button" id="touchDown">‚Üì DOWN</div>
        </div>
    </div>
    <script type="module">
        // Cache busting for local development: use timestamp to force reload
        // This ensures browser always loads latest WASM files during development
        const CACHE_BUST = new URLSearchParams(window.location.search).get('v') || Date.now();
        const wasmUrl = '/client_wasm/client_wasm.js?v=' + CACHE_BUST;
        
        let init, WasmClient;
        try {
            console.log('üì¶ Loading WASM module from:', wasmUrl);
            const module = await import(wasmUrl);
            init = module.default;
            WasmClient = module.WasmClient;
            console.log('‚úÖ WASM module loaded successfully');
        } catch (error) {
            console.error('‚ùå Failed to load WASM module:', error);
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.textContent = 'Error: Failed to load game (check console)';
            }
            throw error;
        }
        
        let client = null;
        let ws = null;
        let scoreLeft = 0;
        let scoreRight = 0;

        function updateStatus(msg) {
            const el = document.getElementById('status');
            if (el) el.textContent = msg;
            console.log('Status:', msg);
        }

        function updateScore(left, right) {
            scoreLeft = left;
            scoreRight = right;
            const el = document.getElementById('score');
            if (el) el.textContent = `${left} : ${right}`;
        }

        function updateMetrics() {
            if (client) {
                try {
                    const metrics = client.get_metrics();
                    if (metrics.length >= 3) {
                        const fpsEl = document.getElementById('fps');
                        const pingEl = document.getElementById('ping');
                        const updateEl = document.getElementById('update');
                        if (fpsEl) fpsEl.textContent = Math.round(metrics[0]);
                        if (pingEl) pingEl.textContent = Math.round(metrics[1]);
                        if (updateEl) updateEl.textContent = Math.round(metrics[2]);
                    }
                } catch (e) {
                    console.error('Metrics error:', e);
                }
            }
        }

        window.createMatch = async function() {
            try {
                updateStatus('Creating match...');
                const response = await fetch('/create');
                const data = await response.json();
                document.getElementById('matchCode').value = data.code;
                updateStatus(`Match created: ${data.code}`);
                await joinMatch();
            } catch (error) {
                console.error('Create error:', error);
                updateStatus('Error creating match');
            }
        };

        window.startLocalGame = async function() {
            try {
                updateStatus('Starting local game...');
                const canvas = document.getElementById('canvas');
                // Ensure canvas has correct size
                if (!canvas.width || !canvas.height) {
                    canvas.width = 640;
                    canvas.height = 480;
                }
                if (!client) {
                    client = await new WasmClient(canvas);
                    console.log('‚úÖ Client initialized');
                }
                client.start_local_game();
                updateStatus('Playing vs AI');
                setupInput();
                startRender();
            } catch (error) {
                console.error('Local game error:', error);
                updateStatus('Error starting local game');
            }
        };

        window.joinMatch = async function() {
            const code = document.getElementById('matchCode').value.trim().toUpperCase();
            if (code.length !== 5) { updateStatus('Match code must be 5 characters'); return; }
            try {
            updateStatus('Initializing client...');
            const canvas = document.getElementById('canvas');
            // Ensure canvas has correct size
            if (!canvas.width || !canvas.height) {
                canvas.width = 800;
                canvas.height = 600;
            }
            console.log('üîç Canvas setup:', {
                width: canvas.width,
                height: canvas.height,
                clientWidth: canvas.clientWidth,
                clientHeight: canvas.clientHeight
            });
            // Don't request WebGPU context here - wgpu will handle it
            // Requesting it here can conflict with wgpu's surface creation
            client = await new WasmClient(canvas);
            console.log('‚úÖ Client initialized');
            updateStatus('Connecting...');
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/${code}`;
            ws = new WebSocket(wsUrl);
            ws.binaryType = 'arraybuffer';
            ws.onopen = () => { 
                console.log('WS connected'); 
                try { 
                    ws.send(client.get_join_bytes(code)); 
                    console.log('Join sent'); 
                    updateStatus('Connected! Waiting for opponent...'); 
                } catch(e) { 
                    console.error('Join error:', e); 
                    updateStatus('Error joining'); 
                    return; 
                } 
                setupInput(); 
                startRender(); 
            };
            ws.onmessage = (event) => { 
                if (event.data instanceof ArrayBuffer) { 
                    try { 
                        client.on_message(new Uint8Array(event.data)); 
                        // Update score display
                        const score = client.get_score();
                        if (score.length >= 2) {
                            updateScore(score[0], score[1]);
                        }
                    } catch (e) { 
                        console.error('Message error:', e); 
                    } 
                } 
            };
            ws.onerror = (error) => { 
                console.error('WS error:', error); 
                updateStatus('Connection error'); 
            };
            ws.onclose = () => { 
                console.log('WS closed'); 
                updateStatus('Disconnected'); 
            };
            } catch (error) {
                console.error('Join error:', error);
                updateStatus('Error: ' + error.message);
            }
        };

        let renderLoopId = null;
        let pingIntervalId = null;
        function startRender() {
            console.log('startRender called, client exists:', !!client);
            function render() {
                if (client) { 
                    try { 
                        client.render();
                        updateMetrics(); // Update metrics display every frame
                        // Update score display (works for both online and local games)
                        const score = client.get_score();
                        if (score.length >= 2) {
                            updateScore(score[0], score[1]);
                        }
                    } catch (e) { 
                        console.error('Render error:', e); 
                    } 
                } else {
                    console.warn('Render called but client is null');
                }
                renderLoopId = requestAnimationFrame(render);
            }
            render();
            
            // Send ping every 2 seconds to measure latency
            pingIntervalId = setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN && client) {
                    try {
                        const pingBytes = client.send_ping();
                        ws.send(pingBytes);
                    } catch (e) {
                        console.error('Ping error:', e);
                    }
                }
            }, 2000);
        }

        function sendInput() {
            if (ws && ws.readyState === WebSocket.OPEN && client) {
                try { 
                    const bytes = client.get_input_bytes();
                    if (bytes.length > 0) {
                        ws.send(bytes); 
                    }
                } catch (e) { 
                    console.error('Input error:', e); 
                }
            }
        }

        function setupInput() {
            // Keyboard controls
            window.addEventListener('keydown', (e) => { 
                if (client) { 
                    client.on_key_down(e); 
                    sendInput(); // Send immediately on keydown
                } 
            });
            window.addEventListener('keyup', (e) => { 
                if (client) { 
                    client.on_key_up(e); 
                    sendInput(); // Send immediately on keyup
                } 
            });
            
            // Touch controls for mobile
            const touchUp = document.getElementById('touchUp');
            const touchDown = document.getElementById('touchDown');
            
            if (touchUp && touchDown) {
                // Prevent default touch behaviors
                const preventDefault = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                };
                
                // Touch start handlers
                touchUp.addEventListener('touchstart', (e) => {
                    preventDefault(e);
                    if (client) {
                        client.handle_key_string('ArrowUp', true);
                        sendInput();
                    }
                });
                
                touchUp.addEventListener('touchend', (e) => {
                    preventDefault(e);
                    if (client) {
                        client.handle_key_string('ArrowUp', false);
                        sendInput();
                    }
                });
                
                touchDown.addEventListener('touchstart', (e) => {
                    preventDefault(e);
                    if (client) {
                        client.handle_key_string('ArrowDown', true);
                        sendInput();
                    }
                });
                
                touchDown.addEventListener('touchend', (e) => {
                    preventDefault(e);
                    if (client) {
                        client.handle_key_string('ArrowDown', false);
                        sendInput();
                    }
                });
                
                // Mouse support for touch buttons (for testing on desktop)
                touchUp.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    if (client) {
                        client.handle_key_string('ArrowUp', true);
                        sendInput();
                    }
                });
                
                touchUp.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    if (client) {
                        client.handle_key_string('ArrowUp', false);
                        sendInput();
                    }
                });
                
                touchDown.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    if (client) {
                        client.handle_key_string('ArrowDown', true);
                        sendInput();
                    }
                });
                
                touchDown.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    if (client) {
                        client.handle_key_string('ArrowDown', false);
                        sendInput();
                    }
                });
            }
            
            // Also send periodically (for holding keys)
            setInterval(sendInput, 33);
        }

        async function main() {
            try {
                console.log('üöÄ Starting main()...');
                await init();
                console.log('‚úÖ WASM initialized');
                updateStatus('Ready to play!');
                const createBtn = document.getElementById('createBtn');
                const joinBtn = document.getElementById('joinBtn');
                const localBtn = document.getElementById('localBtn');
                createBtn.disabled = false;
                joinBtn.disabled = false;
                if (localBtn) localBtn.disabled = false;
                // Use event listeners instead of onclick to avoid timing issues
                createBtn.addEventListener('click', window.createMatch);
                joinBtn.addEventListener('click', window.joinMatch);
                if (localBtn) localBtn.addEventListener('click', window.startLocalGame);
                console.log('‚úÖ UI initialized');
            } catch (error) {
                console.error('‚ùå Error in main():', error);
                updateStatus('Error: ' + error.message);
            }
        }

        // Start immediately (top-level await in module)
        main().catch(error => {
            console.error('‚ùå Fatal error:', error);
            document.getElementById('status').textContent = 'Fatal error: ' + error.message;
        });
    </script>
</body>
</html>

