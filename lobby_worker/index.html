<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pong</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Outfit:wght@700;900&display=swap" rel="stylesheet">
    
    <style>
      :root {
        --bg-dark: #0f172a;
        --bg-deep: #020617;
        --primary: #6366f1;
        --primary-hover: #4f46e5;
        --secondary: #ec4899;
        --accent: #06b6d4;
        --success: #10b981;
        --danger: #ef4444;
        
        --text-main: #f8fafc;
        --text-muted: #94a3b8;
        
        --glass-bg: rgba(30, 41, 59, 0.6);
        --glass-border: rgba(255, 255, 255, 0.08);
        --glass-shine: rgba(255, 255, 255, 0.05);
        
        --shadow-sm: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
        --glow-primary: 0 0 25px rgba(99, 102, 241, 0.25);
      }

      * {
        box-sizing: border-box;
      }

      html {
        background: #020617;
      }
      
      body {
        margin: 0;
        padding: 20px;
        min-height: 100vh;
        overflow-x: hidden;
        overflow-y: auto;
        background: radial-gradient(circle at top center, #1e293b 0%, #020617 100%);
        color: var(--text-main);
        font-family: 'Inter', sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 40px;
        -webkit-user-select: none;
        user-select: none;
        touch-action: none;
      }

      /* Subtle animated grid background */
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        background-image: 
          linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
          linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
        background-size: 50px 50px;
        pointer-events: none;
        z-index: 0;
        mask-image: radial-gradient(circle at center, black 40%, transparent 100%);
      }

      #mainContainer {
        display: flex;
        flex-direction: row;
        align-items: flex-start;
        justify-content: center;
        gap: 40px;
        width: 100%;
        max-width: 1100px;
        position: relative;
        z-index: 1;
      }

      #gameContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        border-radius: 20px;
        padding: 6px;
        background: linear-gradient(145deg, rgba(255,255,255,0.05), rgba(255,255,255,0.01));
        box-shadow: var(--shadow-lg), var(--glow-primary);
        border: 1px solid var(--glass-border);
      }

      #canvas {
        display: block;
        max-width: 100%;
        background: #000;
        border-radius: 14px;
        touch-action: none;
      }

      /* Countdown overlay */
      #countdown {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: 'Outfit', sans-serif;
        font-size: 140px;
        font-weight: 900;
        color: white;
        text-shadow: 0 0 40px var(--primary);
        z-index: 100;
        opacity: 0;
        transition: opacity 0.2s, transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        pointer-events: none;
      }

      #countdown.show {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1);
      }

      /* Victory overlay */
      #victoryOverlay {
        position: absolute;
        inset: 0;
        background: rgba(2, 6, 23, 0.85);
        backdrop-filter: blur(12px);
        border-radius: 14px;
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 200;
        opacity: 0;
        transition: opacity 0.4s ease;
      }

      #victoryOverlay.show {
        display: flex;
        opacity: 1;
      }

      #victoryText {
        font-family: 'Outfit', sans-serif;
        font-size: 64px;
        font-weight: 800;
        margin-bottom: 30px;
        text-align: center;
        letter-spacing: -1px;
      }
      
      .status-win {
        background: linear-gradient(to right, #4ade80, #3b82f6);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 0 30px rgba(74, 222, 128, 0.3);
      }
      
      .status-lose {
        background: linear-gradient(to right, #f472b6, #ef4444);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 0 30px rgba(239, 68, 68, 0.3);
      }

      #playAgainBtn {
        padding: 16px 40px;
        font-size: 18px;
        font-weight: 700;
        font-family: 'Outfit', sans-serif;
        letter-spacing: 1px;
        color: white;
        background: var(--primary);
        border: none;
        border-radius: 100px;
        cursor: pointer;
        box-shadow: 0 10px 20px -5px rgba(99, 102, 241, 0.4);
        transition: all 0.2s ease;
        text-transform: uppercase;
      }

      #playAgainBtn:hover {
        transform: translateY(-2px);
        background: var(--primary-hover);
        box-shadow: 0 15px 25px -5px rgba(99, 102, 241, 0.5);
      }
      
      .victory-buttons {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        justify-content: center;
      }
      
      .btn-quit-overlay {
        padding: 16px 40px;
        font-size: 18px;
        font-weight: 700;
        font-family: 'Outfit', sans-serif;
        letter-spacing: 1px;
        color: white;
        background: #dc2626;
        border: none;
        border-radius: 100px;
        cursor: pointer;
        box-shadow: 0 10px 20px -5px rgba(220, 38, 38, 0.4);
        transition: all 0.2s ease;
        text-transform: uppercase;
      }
      
      .btn-quit-overlay:hover {
        transform: translateY(-2px);
        background: #b91c1c;
        box-shadow: 0 15px 25px -5px rgba(220, 38, 38, 0.5);
      }

      /* Side Panel */
      #sidePanel {
        display: flex;
        flex-direction: column;
        gap: 20px;
        width: 320px;
        flex-shrink: 0;
      }

      /* Card Style */
      .panel-card {
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        border-radius: 16px;
        padding: 24px;
        box-shadow: var(--shadow-sm);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      /* Score Section */
      #scoreContainer {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        width: 100%;
      }

      #score {
        font-family: 'Outfit', sans-serif;
        font-size: 56px;
        font-weight: 800;
        color: white;
        margin: 0;
        text-align: center;
        letter-spacing: -1px;
        line-height: 1;
        transition: transform 0.1s cubic-bezier(0.4, 0, 0.2, 1);
      }

      #score.flash {
        transform: scale(1.15);
        color: var(--accent);
        text-shadow: 0 0 20px rgba(6, 182, 212, 0.5);
      }
      
      #winCondition {
        text-align: center;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--text-muted);
        font-weight: 600;
        margin-top: 4px;
      }

      /* Metrics */
      #metrics {
        display: flex;
        justify-content: center;
        gap: 16px;
        padding: 0;
        background: transparent;
        border: none;
        box-shadow: none;
        opacity: 0.6;
        transition: opacity 0.2s;
      }
      
      #metrics:hover { opacity: 1; }

      .metric-row {
        display: flex;
        align-items: center;
        font-size: 12px;
        color: var(--text-muted);
        font-variant-numeric: tabular-nums;
      }
      
      .metric-label { margin-right: 6px; }
      .metric-value { font-weight: 600; color: var(--text-main); }

      /* UI Controls */
      #playBtn {
        width: 100%;
        padding: 20px;
        font-family: 'Outfit', sans-serif;
        font-size: 20px;
        font-weight: 700;
        letter-spacing: 2px;
        text-transform: uppercase;
        background: linear-gradient(135deg, var(--primary) 0%, #4f46e5 100%);
        border: none;
        color: white;
        border-radius: 12px;
        cursor: pointer;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1), 0 10px 15px -3px rgba(99, 102, 241, 0.3);
        transition: all 0.2s ease;
      }
      
      #playBtn:hover {
        transform: translateY(-2px);
        filter: brightness(1.1);
        box-shadow: 0 20px 25px -5px rgba(99, 102, 241, 0.4);
      }
      
      #playBtn:disabled {
        background: #334155;
        color: #64748b;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      
      #playBtn.playing {
        background: rgba(16, 185, 129, 0.2);
        border: 1px solid rgba(16, 185, 129, 0.4);
        color: #6ee7b7;
        box-shadow: none;
        cursor: default;
        pointer-events: none;
        padding: 14px 20px;
        font-size: 14px;
        letter-spacing: 1px;
      }
      
      .btn-challenge {
        width: 100%;
        padding: 14px 20px;
        background: linear-gradient(135deg, #ec4899 0%, #8b5cf6 100%);
        border: none;
        border-radius: 10px;
        color: white;
        font-family: 'Outfit', sans-serif;
        font-size: 14px;
        font-weight: 700;
        letter-spacing: 1px;
        text-transform: uppercase;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(236, 72, 153, 0.3);
        transition: all 0.2s ease;
      }
      
      .btn-challenge:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(236, 72, 153, 0.4);
      }
      
      .btn-challenge:disabled {
        background: #334155;
        box-shadow: none;
        cursor: not-allowed;
        transform: none;
      }
      
      .btn-quit {
        width: 100%;
        padding: 14px 20px;
        background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
        border: none;
        border-radius: 10px;
        color: white;
        font-family: 'Outfit', sans-serif;
        font-size: 14px;
        font-weight: 700;
        letter-spacing: 1px;
        text-transform: uppercase;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(220, 38, 38, 0.3);
        transition: all 0.2s ease;
        margin-top: 10px;
      }
      
      .btn-quit:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(220, 38, 38, 0.4);
      }
      
      .waiting-state {
        text-align: center;
        padding: 8px 0;
      }
      
      .waiting-text {
        font-size: 13px;
        color: var(--text-main);
        margin-bottom: 8px;
      }
      
      .waiting-subtext {
        font-size: 11px;
        color: var(--success);
        margin-bottom: 12px;
      }
      
      .btn-leave {
        width: 100%;
        padding: 10px;
        background: transparent;
        border: 1px solid rgba(239, 68, 68, 0.3);
        border-radius: 8px;
        color: #fca5a5;
        font-weight: 600;
        font-size: 11px;
        transition: all 0.2s;
        text-transform: uppercase;
      }
      
      .btn-leave:hover {
        background: rgba(239, 68, 68, 0.1);
        color: #f87171;
        border-color: rgba(239, 68, 68, 0.4);
      }
      
      /* Action Buttons (Copy/Share) */
      .header-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid var(--glass-border);
        color: white;
        font-family: 'Outfit', sans-serif;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        font-size: 13px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
        backdrop-filter: blur(4px);
      }
      
      .header-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      }
      
      .header-btn:active {
        transform: translateY(0);
      }

      /* Share Input */
      #shareLinkInput {
        background: rgba(0, 0, 0, 0.4) !important;
        border: 1px solid var(--glass-border) !important;
        color: #e2e8f0 !important;
        font-family: 'Inter', sans-serif;
        font-size: 13px !important;
        padding: 10px 12px !important;
        border-radius: 8px !important;
        transition: all 0.2s;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
      }
      
      #shareLinkInput:focus {
        border-color: var(--primary) !important;
        outline: none;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.3), 0 0 0 2px rgba(99, 102, 241, 0.2);
      }
      
      .controls-info {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid var(--glass-border);
        text-align: center;
        font-size: 11px;
        color: #64748b;
        line-height: 1.6;
      }
      
      /* Hidden helper input for match code */
      #matchCode {
        display: none;
      }

      .mobile-btn {
        display: none;
      }

      /* Share Container */
      .share-row {
        display: flex;
        gap: 8px;
        margin: 10px 0;
        width: 100%;
        align-items: center;
      }
      
      .share-row input {
        flex: 1;
        min-width: 0; /* Allow shrinking */
      }
      
      .share-row button {
        padding: 0 16px; /* Increased clickable area */
        height: 38px; /* Fixed height match input */
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* Mobile Layout */
      @media (max-width: 850px) {
        /* ... existing body/main styling ... */
        body {
          align-items: center; 
          overflow: hidden; 
        }

        #mainContainer {
          flex-direction: column;
          align-items: center;
          justify-content: flex-start;
          gap: 10px;
          height: 100dvh;
          overflow: hidden;
          padding: 10px 0;
        }

        .share-row {
           flex-wrap: wrap;
        }
        
        .share-row input {
           flex-basis: 100%;
           margin-bottom: 4px;
        }
        
        .share-row button {
           flex: 1; /* Buttons share width */
        }
        
        /* ... rest of mobile styling ... */
        #sidePanel {
          width: 90%;
          max-width: 320px;
          order: 2;
          margin-bottom: 0;
          flex-shrink: 1; /* Allow shrinking */
          transform: scale(0.95);
          transform-origin: top center;
        }
        
        /* Adjust card padding for mobile */
        .panel-card {
            padding: 16px; 
            gap: 10px;
        }

        #gameContainer {
          order: 1;
          width: calc(100% - 6px);
          max-width: none;
          flex-shrink: 0;
          flex-grow: 1;
          padding: 3px;
          margin: 3px;
          display: flex;
          align-items: center;
          justify-content: center;
          /* Keep border but minimal */
          border: 1px solid var(--glass-border);
          border-radius: 8px;
          box-shadow: var(--shadow-lg);
          background: linear-gradient(145deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
        }
        
        #canvas {
           width: 100%;
           max-height: 75vh;
           height: auto;
           aspect-ratio: 4/3;
           border-radius: 6px;
        }
        
        /* Mobile: spread buttons to edges */
        #scoreContainer {
          width: 100%;
          justify-content: space-between;
          padding: 0 8px;
        }
        
        /* Mobile Touch Buttons */
        .mobile-btn {
           display: flex;
           align-items: center;
           justify-content: center;
           background: rgba(255,255,255,0.08);
           border: 1px solid var(--glass-border);
           color: var(--text-main);
           font-size: 24px;
           width: 60px;
           height: 60px;
           border-radius: 12px;
           cursor: pointer;
           touch-action: manipulation;
           user-select: none;
           -webkit-user-select: none;
        }
        
        .mobile-btn:active {
          background: rgba(255,255,255,0.2);
          transform: scale(0.95);
        }
        
        /* Hide keyboard controls text on mobile */
        .controls-info {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="mainContainer">
      <!-- Game Area -->
      <div id="gameContainer">
        <canvas id="canvas" width="640" height="480"></canvas>
        <div id="countdown"></div>
        <div id="victoryOverlay">
          <div id="victoryText">VICTORY</div>
          <div class="victory-buttons">
            <button id="playAgainBtn">Play Again</button>
            <button id="quitGameBtn" class="btn-quit-overlay">Quit</button>
          </div>
        </div>
      </div>
      
      <!-- Side/Control Panel -->
      <div id="sidePanel">
        <!-- Single Control Card -->
        <div class="panel-card">
          <div id="scoreRow">
            <div id="scoreContainer">
              <button id="mobileUp" class="mobile-btn">▲</button>
              <div id="score">0 : 0</div>
              <button id="mobileDown" class="mobile-btn">▼</button>
            </div>
            <div id="winCondition">First to 5 Wins</div>
          </div>
          
          <div id="metrics">
            <div class="metric-row">
              <span class="metric-label">FPS</span>
              <span class="metric-value" id="fps">--</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">PING</span>
              <span class="metric-value" id="ping">--</span>
              <span style="font-size: 10px; margin-left: 2px;">ms</span>
            </div>
          </div>
          
          <button id="playBtn" disabled>Play Now</button>
          
          <!-- Hidden input to store match code -->
          <input type="text" id="matchCode" maxlength="5" />
          
          <!-- Multiplayer: Create match button -->
          <div id="lobbyControls">
            <button id="createBtn" class="btn-challenge">Challenge a Friend</button>
          </div>
          
          <!-- Quit button for local games -->
          <button id="quitBtn" class="btn-quit" style="display: none;">Quit Game</button>
          <!-- Waiting for opponent -->
          <div id="activeMatchControls" style="display: none;">
            <div class="waiting-state">
              <div class="waiting-text" style="font-size: 1.1em;">Waiting for opponent...</div>
              
              <div class="share-row">
                <input type="text" id="shareLinkInput" readonly>
                <button id="copyLinkBtn" class="btn header-btn">Copy</button>
                <button id="shareLinkBtn" class="btn header-btn" style="display: none;">Share</button>
              </div>

              <div id="copyFeedback" style="font-size: 0.9em; color: var(--accent); margin-bottom: 8px; min-height: 1.2em;"></div>
              <div style="font-size: 0.85em; opacity: 0.8; margin-bottom: 15px;">Send link to join!</div>
              <button id="leaveBtn" class="btn-leave">Cancel</button>
            </div>
          </div>
          
          <div class="controls-info">
            CONTROLS<br>
            W / S or ↑ / ↓ to Move
          </div>
        </div>
      </div>
      
      <!-- Ko-fi Support Button -->
      <div style="margin-top: 20px; z-index: 1000; display: flex; justify-content: center; width: 100%;">
        <a href="https://ko-fi.com/N4N31DPNUS" target="_blank" rel="noopener noreferrer">
          <img height="36" style="border:0px;height:36px;" src="https://storage.ko-fi.com/cdn/kofi2.png?v=6" alt="Buy Me a Coffee at ko-fi.com" />
        </a>
      </div>
    </div>

    <!-- JS Logic -->
    <script type="module">
      // Sound effects using Web Audio API
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      let audioCtx = null;

      function initAudio() {
        if (!audioCtx) {
          audioCtx = new AudioContext();
        }
      }

      function playSound(type) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        switch (type) {
          case "paddle":
            osc.frequency.setValueAtTime(440, audioCtx.currentTime);
            osc.type = "sine";
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
            break;
          case "wall":
            osc.frequency.setValueAtTime(220, audioCtx.currentTime);
            osc.type = "sine";
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.08);
            break;
          case "score":
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.2);
            osc.type = "triangle";
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
            break;
          case "victory":
            [0, 0.15, 0.3].forEach((delay, i) => {
              const o = audioCtx.createOscillator();
              const g = audioCtx.createGain();
              o.connect(g);
              g.connect(audioCtx.destination);
              o.frequency.setValueAtTime([523, 659, 784][i], audioCtx.currentTime + delay);
              o.type = "triangle";
              g.gain.setValueAtTime(0.1, audioCtx.currentTime + delay);
              g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + delay + 0.3);
              o.start(audioCtx.currentTime + delay);
              o.stop(audioCtx.currentTime + delay + 0.3);
            });
            break;
        }
      }

      const CACHE_BUST = new URLSearchParams(window.location.search).get("v") || Date.now();
      const wasmUrl = "/client_wasm/client_wasm.js?v=" + CACHE_BUST;

      let init, WasmClient;
      try {
        const module = await import(wasmUrl);
        init = module.default;
        WasmClient = module.WasmClient;
      } catch (error) {
        console.error("Failed to load WASM:", error);
        document.getElementById("status").textContent = "Failed to load game resource";
        throw error;
      }

      let client = null;
      let ws = null;
      let lastScore = [0, 0];
      let renderLoopId = null;
      let pingIntervalId = null;
      let inputIntervalId = null;
      let currentMatchCode = null;

      // ========================================
      // Finite State Machine
      // ========================================
      const GameState = {
        IDLE: 'IDLE',
        COUNTDOWN_LOCAL: 'COUNTDOWN_LOCAL',
        PLAYING_LOCAL: 'PLAYING_LOCAL',
        CONNECTING: 'CONNECTING',
        WAITING: 'WAITING',
        COUNTDOWN_MULTI: 'COUNTDOWN_MULTI',
        PLAYING_MULTI: 'PLAYING_MULTI',
        GAME_OVER_LOCAL: 'GAME_OVER_LOCAL',
        GAME_OVER_MULTI: 'GAME_OVER_MULTI',
        DISCONNECTED: 'DISCONNECTED'
      };

      const FSM = {
        state: GameState.IDLE,

        // Valid transitions: current state -> action -> next state
        transitions: {
          [GameState.IDLE]: {
            'START_LOCAL': GameState.COUNTDOWN_LOCAL,
            'CREATE_MATCH': GameState.CONNECTING,
            'JOIN_MATCH': GameState.CONNECTING
          },
          [GameState.COUNTDOWN_LOCAL]: {
            'COUNTDOWN_DONE': GameState.PLAYING_LOCAL,
            'QUIT': GameState.IDLE
          },
          [GameState.PLAYING_LOCAL]: {
            'GAME_OVER': GameState.GAME_OVER_LOCAL,
            'QUIT': GameState.IDLE
          },
          [GameState.CONNECTING]: {
            'CONNECTED': GameState.WAITING,
            'CONNECTION_FAILED': GameState.IDLE
          },
          [GameState.WAITING]: {
            'OPPONENT_JOINED': GameState.COUNTDOWN_MULTI,
            'DISCONNECTED': GameState.IDLE,
            'LEAVE': GameState.IDLE
          },
          [GameState.COUNTDOWN_MULTI]: {
            'COUNTDOWN_DONE': GameState.PLAYING_MULTI,
            'DISCONNECTED': GameState.DISCONNECTED
          },
          [GameState.PLAYING_MULTI]: {
            'GAME_OVER': GameState.GAME_OVER_MULTI,
            'DISCONNECTED': GameState.DISCONNECTED
          },
          [GameState.GAME_OVER_LOCAL]: {
            'PLAY_AGAIN': GameState.COUNTDOWN_LOCAL,
            'LEAVE': GameState.IDLE
          },
          [GameState.GAME_OVER_MULTI]: {
            'REMATCH_STARTED': GameState.COUNTDOWN_MULTI,
            'DISCONNECTED': GameState.DISCONNECTED,
            'LEAVE': GameState.IDLE
          },
          [GameState.DISCONNECTED]: {
            'LEAVE': GameState.IDLE
          }
        },

        canTransition(action) {
          const possibleTransitions = this.transitions[this.state];
          return possibleTransitions && possibleTransitions[action];
        },

        async transition(action) {
          const nextState = this.transitions[this.state]?.[action];
          if (!nextState) {
            console.warn(`Invalid transition: ${this.state} + ${action}`);
            return false;
          }
          console.log(`FSM: ${this.state} --[${action}]--> ${nextState}`);
          await this.exitState(this.state);
          this.state = nextState;
          await this.enterState(nextState);
          return true;
        },

        async exitState(state) {
          switch (state) {
            case GameState.PLAYING_LOCAL:
            case GameState.PLAYING_MULTI:
              stopGameLoop();
              break;
            case GameState.WAITING:
            case GameState.COUNTDOWN_MULTI:
              stopEventPolling();
              hideCountdownNumber();
              break;
            case GameState.GAME_OVER_MULTI:
              stopEventPolling();
              // Fallthrough
            case GameState.GAME_OVER_LOCAL:
              hideVictoryOverlay();
              break;
            case GameState.CONNECTING:
          }
        },

        async enterState(state) {
          updateUIForState(state);
          switch (state) {
            case GameState.IDLE:
              await enterIdle();
              break;
            case GameState.COUNTDOWN_LOCAL:
              await enterCountdownLocal();
              break;
            case GameState.PLAYING_LOCAL:
              enterPlayingLocal();
              break;
            case GameState.CONNECTING:
              await enterConnecting();
              break;
            case GameState.WAITING:
              enterWaiting();
              break;
            case GameState.COUNTDOWN_MULTI:
              await enterCountdownMulti();
              break;
            case GameState.PLAYING_MULTI:
              enterPlayingMulti();
              break;
            case GameState.GAME_OVER_LOCAL:
            case GameState.GAME_OVER_MULTI:
              // Winner is set by showVictory call before transition
              // Also ensure event polling continues for multi
              if (state === GameState.GAME_OVER_MULTI) {
                startEventPolling();
              }
              break;
            case GameState.DISCONNECTED:
              enterDisconnected();
              break;
          }
        }
      };

      // ========================================
      // State Entry Handlers
      // ========================================
      async function enterIdle() {
        closeWebSocket();
        stopGameLoop();
        lastScore = [0, 0];
        currentMatchCode = null;
        
        // Clear URL params
        const url = new URL(window.location);
        if (url.searchParams.has('code')) {
          url.searchParams.delete('code');
          window.history.pushState({}, '', url);
        }
        document.getElementById('matchCode').value = '';
      }

      async function enterCountdownLocal() {
        initAudio();
        const canvas = document.getElementById('canvas');
        if (!client) {
          client = await new WasmClient(canvas);
        }
        await showCountdown();
        FSM.transition('COUNTDOWN_DONE');
      }

      function enterPlayingLocal() {
        client.start_local_game();
        lastScore = [0, 0];
        updateScore(0, 0);
        document.body.classList.add('game-active');
        setupInputIfNeeded();
        startRenderLoop();
      }

      async function enterConnecting() {
        initAudio();
        const canvas = document.getElementById('canvas');
        if (!client) {
          client = await new WasmClient(canvas);
        }
        
        const code = currentMatchCode || document.getElementById('matchCode').value.trim().toUpperCase();
        if (code.length !== 5) {
          FSM.transition('CONNECTION_FAILED');
          return;
        }
        currentMatchCode = code;
        
        // Update URL
        const url = new URL(window.location);
        if (url.searchParams.get('code') !== code) {
          url.searchParams.set('code', code);
          window.history.pushState({}, '', url);
        }
        
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws/${code}`;
        
        try {
          ws = new WebSocket(wsUrl);
          ws.binaryType = 'arraybuffer';
          
          ws.onopen = () => {
            try {
              ws.send(client.get_join_bytes(code));
              FSM.transition('CONNECTED');
            } catch (e) {
              console.error('Join error:', e);
              FSM.transition('CONNECTION_FAILED');
            }
          };
          
          ws.onmessage = (event) => {
            if (event.data instanceof ArrayBuffer) {
              try {
                client.on_message(new Uint8Array(event.data));
                
                // Poll for match events from server
                const matchEvent = client.get_match_event();
                if (matchEvent) {
                  handleMatchEvent(matchEvent);
                }
                
                // Update score if playing
                if (FSM.state === GameState.PLAYING_MULTI) {
                  const score = client.get_score();
                  if (score.length >= 2) {
                    updateScore(score[0], score[1]);
                  }
                }
              } catch (e) { console.error('Message error:', e); }
            }
          };
          
          ws.onerror = () => {
            if (FSM.state === GameState.CONNECTING) {
              FSM.transition('CONNECTION_FAILED');
            }
          };
          
          ws.onclose = () => {
            if (FSM.state === GameState.WAITING || FSM.state === GameState.COUNTDOWN_MULTI) {
              FSM.transition('DISCONNECTED');
            } else if (FSM.state === GameState.PLAYING_MULTI || FSM.state === GameState.GAME_OVER_MULTI) {
              FSM.transition('DISCONNECTED');
            } else if (FSM.state === GameState.CONNECTING) {
              FSM.transition('CONNECTION_FAILED');
            }
          };
        } catch (e) {
          FSM.transition('CONNECTION_FAILED');
        }
      }

      function enterWaiting() {
        // Start polling for events while waiting
        startEventPolling();
      }

      async function enterCountdownMulti() {
        // Reset client state for fresh start - critical for rematch smoothness
        if (client) {
          client.reset_for_multiplayer();
        }
        // Server drives the countdown - we just display what it sends
        // The countdown display is handled by handleMatchEvent
        // Wait here until game_start is received
        // (Transition to PLAYING_MULTI is triggered by handleMatchEvent)
      }

      // Handle match events from server
      function handleMatchEvent(event) {
        console.log('Match event:', event, 'State:', FSM.state);
        
        if (event === 'match_found') {
          if (FSM.state === GameState.WAITING) {
            playSound('paddle');
            FSM.transition('OPPONENT_JOINED');
          }
        } else if (event.startsWith('countdown:')) {
          const seconds = parseInt(event.split(':')[1]);
          showCountdownNumber(seconds);
          
          if (FSM.state === GameState.GAME_OVER_MULTI) {
             FSM.transition('REMATCH_STARTED');
          }
        } else if (event === 'game_start') {
          hideCountdownNumber();
          if (FSM.state === GameState.COUNTDOWN_MULTI) {
            FSM.transition('COUNTDOWN_DONE');
          }
        } else if (event === 'opponent_disconnected') {
          if (FSM.state === GameState.WAITING || FSM.state === GameState.COUNTDOWN_MULTI || FSM.state === GameState.GAME_OVER_MULTI) {
            FSM.transition('DISCONNECTED');
          }
        }
      }

      // Show a single countdown number
      function showCountdownNumber(n) {
        const el = document.getElementById('countdown');
        el.textContent = n > 0 ? n.toString() : 'GO!';
        el.classList.add('show');
        playSound('paddle');
        setTimeout(() => el.classList.remove('show'), 800);
      }

      function hideCountdownNumber() {
        document.getElementById('countdown').classList.remove('show');
      }

      let eventPollingId = null;
      function startEventPolling() {
        stopEventPolling();
        eventPollingId = setInterval(() => {
          if (client && ws && ws.readyState === WebSocket.OPEN) {
            const matchEvent = client.get_match_event();
            if (matchEvent) {
              handleMatchEvent(matchEvent);
            }
          }
        }, 100);
      }

      function stopEventPolling() {
        if (eventPollingId) {
          clearInterval(eventPollingId);
          eventPollingId = null;
        }
      }

      function enterPlayingMulti() {
        lastScore = [0, 0];
        document.body.classList.add('game-active');
        setupInputIfNeeded();
        startRenderLoop();
        startPingInterval();
        // Start input polling (must be called every game, not just once)
        if (!inputIntervalId) {
          inputIntervalId = setInterval(sendInput, 33);
        }
      }

      function enterDisconnected() {
        closeWebSocket();
        stopGameLoop();
      }

      // ========================================
      // UI Updates
      // ========================================
      function updateUIForState(state) {
        const playBtn = document.getElementById('playBtn');
        const lobbyControls = document.getElementById('lobbyControls');
        const activeMatchControls = document.getElementById('activeMatchControls');
        const quitBtn = document.getElementById('quitBtn');
        
        switch (state) {
          case GameState.IDLE:
            playBtn.textContent = 'Play Now';
            playBtn.disabled = false;
            playBtn.classList.remove('playing');
            lobbyControls.style.display = 'block';
            activeMatchControls.style.display = 'none';
            quitBtn.style.display = 'none';
            document.body.classList.remove('game-active');
            break;
            
          case GameState.COUNTDOWN_LOCAL:
            playBtn.textContent = 'Starting...';
            playBtn.disabled = true;
            lobbyControls.style.display = 'none';
            quitBtn.style.display = 'block';
            break;
            
          case GameState.PLAYING_LOCAL:
            playBtn.textContent = 'Playing vs AI';
            playBtn.classList.add('playing');
            lobbyControls.style.display = 'none';
            quitBtn.style.display = 'block';
            break;
            
          case GameState.CONNECTING:
            playBtn.textContent = 'Connecting...';
            playBtn.disabled = true;
            lobbyControls.style.display = 'none';
            activeMatchControls.style.display = 'block';
            break;
            
          case GameState.WAITING:
            playBtn.textContent = 'Waiting...';
            break;
            
          case GameState.COUNTDOWN_MULTI:
            playBtn.textContent = 'Get Ready!';
            activeMatchControls.style.display = 'none';
            break;
            
          case GameState.PLAYING_MULTI:
            playBtn.textContent = 'In Match';
            playBtn.classList.add('playing');
            lobbyControls.style.display = 'none';
            activeMatchControls.style.display = 'none';
            break;

          case GameState.GAME_OVER_LOCAL:
          case GameState.GAME_OVER_MULTI:
            playBtn.textContent = 'Game Over';
            playBtn.classList.remove('playing');
            activeMatchControls.style.display = 'none';
            break;
            
          case GameState.DISCONNECTED:
            playBtn.textContent = 'Disconnected';
            playBtn.disabled = false;
            playBtn.classList.remove('playing');
            document.body.classList.remove('game-active');
            break;
        }
      }

      function updateScore(left, right) {
        const el = document.getElementById('score');
        if (el) {
          if (left !== lastScore[0] || right !== lastScore[1]) {
            playSound('score');
            el.classList.add('flash');
            setTimeout(() => el.classList.remove('flash'), 200);
            lastScore = [left, right];
          }
          el.textContent = `${left} : ${right}`;
        }
      }

      function updateMetrics() {
        if (client) {
          try {
            const metrics = client.get_metrics();
            if (metrics.length >= 2) {
              document.getElementById('fps').textContent = Math.round(metrics[0]);
              document.getElementById('ping').textContent = Math.round(metrics[1]);
            }
          } catch (e) {}
        }
      }

      // ========================================
      // Game Loop
      // ========================================
      function startRenderLoop() {
        function render() {
          if (client) {
            try {
              client.render();
              updateMetrics();
              const score = client.get_score();
              if (score.length >= 2) {
                updateScore(score[0], score[1]);
                
                // Check for game over
                const winner = client.get_winner();
                if (winner) {
                  showVictory(winner);
                  FSM.transition('GAME_OVER');
                  return;
                }
                if (score[0] >= 5 || score[1] >= 5) {
                  const winnerName = score[0] >= 5 ? 'you' : 'opponent';
                  showVictory(winnerName);
                  if (FSM.state === GameState.PLAYING_LOCAL) {
                    FSM.transition('GAME_OVER_LOCAL');
                  } else {
                    FSM.transition('GAME_OVER_MULTI');
                  }
                  return;
                }
              }
            } catch (e) {}
          }
          
          if (FSM.state === GameState.PLAYING_LOCAL || FSM.state === GameState.PLAYING_MULTI) {
            renderLoopId = requestAnimationFrame(render);
          }
        }
        render();
      }

      function stopGameLoop() {
        if (renderLoopId) {
          cancelAnimationFrame(renderLoopId);
          renderLoopId = null;
        }
        if (pingIntervalId) {
          clearInterval(pingIntervalId);
          pingIntervalId = null;
        }
        if (inputIntervalId) {
          clearInterval(inputIntervalId);
          inputIntervalId = null;
        }
      }

      function startPingInterval() {
        pingIntervalId = setInterval(() => {
          if (ws && ws.readyState === WebSocket.OPEN && client) {
            try {
              const pingBytes = client.send_ping();
              ws.send(pingBytes);
            } catch (e) {}
          }
        }, 2000);
      }

      // ========================================
      // WebSocket & Input
      // ========================================
      function closeWebSocket() {
        if (ws) {
          ws.close();
          ws = null;
        }
      }

      function sendInput() {
        if (ws && ws.readyState === WebSocket.OPEN && client) {
          try {
            const bytes = client.get_input_bytes();
            if (bytes.length > 0) {
              ws.send(bytes);
            }
          } catch (e) {}
        }
      }

      let inputSetup = false;
      function setupInputIfNeeded() {
        if (inputSetup) return;
        inputSetup = true;
        
        const pressedKeys = new Set();
        window.addEventListener('keydown', (e) => {
          const gameKeys = ['ArrowUp', 'ArrowDown', 'w', 'W', 's', 'S'];
          if (gameKeys.includes(e.key)) {
            e.preventDefault();
            const upKeys = ['ArrowUp', 'w', 'W'];
            const downKeys = ['ArrowDown', 's', 'S'];
            if (upKeys.includes(e.key)) {
              downKeys.forEach(key => {
                if (pressedKeys.has(key)) {
                  pressedKeys.delete(key);
                  if (client) client.handle_key_string(key, false);
                }
              });
              pressedKeys.add(e.key);
            } else if (downKeys.includes(e.key)) {
              upKeys.forEach(key => {
                if (pressedKeys.has(key)) {
                  pressedKeys.delete(key);
                  if (client) client.handle_key_string(key, false);
                }
              });
              pressedKeys.add(e.key);
            }
          }
          if (client) {
            client.on_key_down(e);
            sendInput();
          }
        }, { capture: true, passive: false });

        window.addEventListener('keyup', (e) => {
          const gameKeys = ['ArrowUp', 'ArrowDown', 'w', 'W', 's', 'S'];
          if (gameKeys.includes(e.key)) {
            e.preventDefault();
            pressedKeys.delete(e.key);
          }
          if (client) {
            client.on_key_up(e);
            sendInput();
          }
        }, { capture: true, passive: false });

        const mobileUp = document.getElementById('mobileUp');
        const mobileDown = document.getElementById('mobileDown');

        const setupTouch = (info) => {
          const btn = info.btn;
          const key = info.key;
          if (!btn) return;
          const handle = (e, isDown) => {
            if (e.type !== 'click') e.preventDefault();
            if (client) {
              client.handle_key_string(key, isDown);
              sendInput();
            }
          };
          btn.addEventListener('touchstart', (e) => handle(e, true), { passive: false });
          btn.addEventListener('touchend', (e) => handle(e, false), { passive: false });
          btn.addEventListener('mousedown', (e) => handle(e, true));
          btn.addEventListener('mouseup', (e) => handle(e, false));
          btn.addEventListener('mouseleave', (e) => handle(e, false));
        };
        setupTouch({ btn: mobileUp, key: 'ArrowUp' });
        setupTouch({ btn: mobileDown, key: 'ArrowDown' });
        // Note: inputIntervalId is now started in enterPlayingMulti() to ensure it restarts on rematch
      }

      // ========================================
      // Victory/Countdown Overlays
      // ========================================
      async function showCountdown() {
        const el = document.getElementById('countdown');
        for (const text of ['3', '2', '1', 'GO!']) {
          el.textContent = text;
          el.classList.add('show');
          playSound('paddle');
          await new Promise(r => setTimeout(r, 600));
          el.classList.remove('show');
          await new Promise(r => setTimeout(r, 100));
        }
      }

      function showVictory(winner) {
        playSound('victory');
        const overlay = document.getElementById('victoryOverlay');
        const text = document.getElementById('victoryText');
        
        if (winner === 'you') {
          text.textContent = 'VICTORY';
          text.className = 'status-win';
        } else {
          text.textContent = 'DEFEAT';
          text.className = 'status-lose';
        }
        
        // Reset button
        const btn = document.getElementById('playAgainBtn');
        btn.textContent = 'Play Again';
        btn.disabled = false;
        
        overlay.classList.add('show');
        document.body.classList.remove('game-active');
      }

      function hideVictoryOverlay() {
        document.getElementById('victoryOverlay').classList.remove('show');
      }

      // ========================================
      // Public API / Event Handlers
      // ========================================
      window.startLocalGame = async function() {
        if (FSM.state === GameState.IDLE) {
          await FSM.transition('START_LOCAL');
        } else if (FSM.state === GameState.GAME_OVER_LOCAL) {
          await FSM.transition('PLAY_AGAIN');
        }
      };

      window.createMatch = async function() {
        if (FSM.state !== GameState.IDLE) return;
        try {
          const response = await fetch('/create');
          const data = await response.json();
          document.getElementById('matchCode').value = data.code;
          currentMatchCode = data.code;
          
          // Build and copy invite URL
          const url = new URL(window.location);
          url.searchParams.set('code', data.code);
          const linkStr = url.toString();
          
          document.getElementById('shareLinkInput').value = linkStr;
          const feedback = document.getElementById('copyFeedback');
          
          try {
            await navigator.clipboard.writeText(linkStr);
            feedback.textContent = '✓ Link copied to clipboard!';
            feedback.style.color = 'var(--accent)';
          } catch (e) {
            console.warn('Could not copy to clipboard:', e);
            feedback.textContent = 'Please copy the link manually';
            feedback.style.color = '#ffaa00';
          }
          
          await FSM.transition('CREATE_MATCH');
        } catch (e) {
          console.error('Create match error:', e);
        }
      };
      
      // Manual copy button handler
      document.getElementById('copyLinkBtn').addEventListener('click', async () => {
        const input = document.getElementById('shareLinkInput');
        const feedback = document.getElementById('copyFeedback');
        try {
          input.select();
          input.setSelectionRange(0, 99999); // For mobile devices
          await navigator.clipboard.writeText(input.value);
          feedback.textContent = '✓ Link copied manually!';
          feedback.style.color = 'var(--accent)';
        } catch (e) {
             // Fallback
             document.execCommand('copy');
             feedback.textContent = '✓ Link copied manually!';
        }
      });

      // Native Share API handler
      if (navigator.share) {
        document.getElementById('shareLinkBtn').style.display = 'inline-block';
      }
      
      document.getElementById('shareLinkBtn').addEventListener('click', async () => {
        const link = document.getElementById('shareLinkInput').value;
        try {
          await navigator.share({
            title: 'Lets Play Pong!',
            text: 'Join me for a match of Pong!',
            url: link
          });
        } catch (err) {
          console.error('Share failed:', err);
        }
      });

      window.joinMatch = async function() {
        if (FSM.state !== GameState.IDLE) return;
        const code = document.getElementById('matchCode').value.trim().toUpperCase();
        if (code.length !== 5) return;
        currentMatchCode = code;
        await FSM.transition('JOIN_MATCH');
      };

      window.leaveGame = function() {
        if (FSM.canTransition('LEAVE')) {
          FSM.transition('LEAVE');
        }
      };

      // ========================================
      // Initialization
      // ========================================
      document.getElementById('playAgainBtn').addEventListener('click', () => {
        if (FSM.state === GameState.GAME_OVER_LOCAL) {
          FSM.transition('PLAY_AGAIN');
        } else if (FSM.state === GameState.GAME_OVER_MULTI) {
          // Send restart request
          if (client && ws && ws.readyState === WebSocket.OPEN) {
              try {
                  const bytes = client.get_restart_bytes();
                  ws.send(bytes);
                  // Immediate reset for better UX
                  client.reset_local_state();
                  hideVictoryOverlay();
              } catch (e) { console.error(e); }
          }
        }
      });

      document.getElementById('leaveBtn').addEventListener('click', () => {
        window.leaveGame();
      });

      async function main() {
        try {
          await init();
          document.getElementById('playBtn').disabled = false;
          document.getElementById('playBtn').addEventListener('click', window.startLocalGame);
          document.getElementById('createBtn').addEventListener('click', window.createMatch);
          document.getElementById('quitBtn').addEventListener('click', () => {
            // Stop the local game and return to idle
            stopGameLoop();
            if (client) {
              client.stop_local_game();
            }
            FSM.transition('QUIT');
          });
          
          document.getElementById('quitGameBtn').addEventListener('click', async () => {
            // Close WebSocket connection and return to idle
            closeWebSocket();
            stopGameLoop();
            hideVictoryOverlay();
            await FSM.transition('LEAVE');
          });

          // Auto-join if code in URL
          const urlParams = new URLSearchParams(window.location.search);
          const code = urlParams.get('code');
          if (code) {
            document.getElementById('matchCode').value = code;
            currentMatchCode = code;
            await FSM.transition('JOIN_MATCH');
          }
        } catch (error) {
          console.error('Init error:', error);
        }
      }

      main().catch((error) => {
        console.error('Fatal error:', error);
      });
    </script>
  </body>
</html>
