<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Pong</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Outfit:wght@700;900&display=swap" rel="stylesheet">
    
    <style>
      :root {
        --bg-dark: #0f172a;
        --bg-deep: #020617;
        --primary: #6366f1;
        --primary-hover: #4f46e5;
        --secondary: #ec4899;
        --accent: #06b6d4;
        --success: #10b981;
        --danger: #ef4444;
        
        --text-main: #f8fafc;
        --text-muted: #94a3b8;
        
        --glass-bg: rgba(30, 41, 59, 0.6);
        --glass-border: rgba(255, 255, 255, 0.08);
        --glass-shine: rgba(255, 255, 255, 0.05);
        
        --shadow-sm: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
        --glow-primary: 0 0 25px rgba(99, 102, 241, 0.25);
      }

      * {
        box-sizing: border-box;
      }

      html {
        background: #020617;
      }
      
      body {
        margin: 0;
        padding: 0;
        min-height: 100vh;
        height: 100vh;
        overflow: hidden;
        position: fixed;
        width: 100%;
        touch-action: none;
        background: radial-gradient(circle at top center, #1e293b 0%, #020617 100%);
        color: var(--text-main);
        font-family: 'Inter', sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        -webkit-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
      }

      /* Subtle animated grid background */
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        background-image: 
          linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
          linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
        background-size: 50px 50px;
        pointer-events: none;
        z-index: 0;
        mask-image: radial-gradient(circle at center, black 40%, transparent 100%);
      }

      #mainContainer {
        display: flex;
        flex-direction: row;
        align-items: center; /* Center align items vertically */
        justify-content: center;
        gap: 24px;
        width: 100%;
        max-width: 1100px;
        position: relative;
        z-index: 1;
      }

      #gameContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        border-radius: 16px;
        padding: 0; /* Remove padding for cleaner look */
        background: black;
        box-shadow: 
           0 0 0 1px var(--glass-border),
           0 20px 50px -10px rgba(0, 0, 0, 0.5),
           0 0 30px rgba(99, 102, 241, 0.15); /* Slight glow */
        overflow: hidden;
        flex-shrink: 0;
      }

      #canvas {
        display: block;
        background: #000;
        touch-action: none;
      }

      /* Countdown overlay */
      #countdown {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: 'Outfit', sans-serif;
        font-size: 140px;
        font-weight: 900;
        color: white;
        text-shadow: 0 0 40px var(--primary);
        z-index: 100;
        opacity: 0;
        transition: opacity 0.2s, transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        pointer-events: none;
      }

      #countdown.show {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1);
      }

      /* Victory overlay */
      #victoryOverlay {
        position: absolute;
        inset: 0;
        background: rgba(2, 6, 23, 0.85);
        backdrop-filter: blur(12px);
        border-radius: 14px;
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 200;
        opacity: 0;
        transition: opacity 0.4s ease;
      }

      #victoryOverlay.show {
        display: flex;
        opacity: 1;
      }

      #victoryText {
        font-family: 'Outfit', sans-serif;
        font-size: 64px;
        font-weight: 800;
        margin-bottom: 30px;
        text-align: center;
        letter-spacing: -1px;
      }
      
      .status-win {
        background: linear-gradient(to right, #4ade80, #3b82f6);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 0 30px rgba(74, 222, 128, 0.3);
      }
      
      .status-lose {
        background: linear-gradient(to right, #f472b6, #ef4444);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 0 30px rgba(239, 68, 68, 0.3);
      }

      #playAgainBtn {
        padding: 16px 40px;
        font-size: 18px;
        font-weight: 700;
        font-family: 'Outfit', sans-serif;
        letter-spacing: 1px;
        color: white;
        background: var(--primary);
        border: none;
        border-radius: 100px;
        cursor: pointer;
        box-shadow: 0 10px 20px -5px rgba(99, 102, 241, 0.4);
        transition: all 0.2s ease;
        text-transform: uppercase;
      }

      #playAgainBtn:hover {
        transform: translateY(-2px);
        background: var(--primary-hover);
        box-shadow: 0 15px 25px -5px rgba(99, 102, 241, 0.5);
      }
      
      .victory-buttons {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        justify-content: center;
      }
      
      .btn-quit-overlay {
        padding: 16px 40px;
        font-size: 18px;
        font-weight: 700;
        font-family: 'Outfit', sans-serif;
        letter-spacing: 1px;
        color: white;
        background: #dc2626;
        border: none;
        border-radius: 100px;
        cursor: pointer;
        box-shadow: 0 10px 20px -5px rgba(220, 38, 38, 0.4);
        transition: all 0.2s ease;
        text-transform: uppercase;
      }
      
      .btn-quit-overlay:hover {
        transform: translateY(-2px);
        background: #b91c1c;
        box-shadow: 0 15px 25px -5px rgba(220, 38, 38, 0.5);
      }

      /* Side Panel */
      #sidePanel {
        display: flex;
        flex-direction: column;
        gap: 20px;
        width: 320px;
        flex-shrink: 0;
      }

      /* Card Style */
      .panel-card {
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        border-radius: 16px;
        padding: 24px;
        box-shadow: var(--shadow-sm);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      /* Score Section */
      #scoreContainer {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        width: 100%;
      }

      #score {
        font-family: 'Outfit', sans-serif;
        font-size: 56px;
        font-weight: 800;
        color: white;
        margin: 0;
        text-align: center;
        letter-spacing: -1px;
        line-height: 1;
        transition: transform 0.1s cubic-bezier(0.4, 0, 0.2, 1);
      }

      #score.flash {
        transform: scale(1.15);
        color: var(--accent);
        text-shadow: 0 0 20px rgba(6, 182, 212, 0.5);
      }
      
      #winCondition {
        text-align: center;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--text-muted);
        font-weight: 600;
        margin-top: 4px;
      }

      /* Metrics */
      #metrics {
        display: flex;
        justify-content: center;
        gap: 16px;
        padding: 0;
        background: transparent;
        border: none;
        box-shadow: none;
        opacity: 0.6;
        transition: opacity 0.2s;
      }
      
      #metrics:hover { opacity: 1; }

      .metric-row {
        display: flex;
        align-items: center;
        font-size: 12px;
        color: var(--text-muted);
        font-variant-numeric: tabular-nums;
      }
      
      .metric-label { margin-right: 6px; }
      .metric-value { font-weight: 600; color: var(--text-main); }

      /* UI Controls */
      #playBtn {
        width: 100%;
        padding: 20px;
        font-family: 'Outfit', sans-serif;
        font-size: 20px;
        font-weight: 700;
        letter-spacing: 2px;
        text-transform: uppercase;
        background: linear-gradient(135deg, var(--primary) 0%, #4f46e5 100%);
        border: none;
        color: white;
        border-radius: 12px;
        cursor: pointer;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1), 0 10px 15px -3px rgba(99, 102, 241, 0.3);
        transition: all 0.2s ease;
      }
      
      #playBtn:hover {
        transform: translateY(-2px);
        filter: brightness(1.1);
        box-shadow: 0 20px 25px -5px rgba(99, 102, 241, 0.4);
      }
      
      #playBtn:disabled {
        background: #334155;
        color: #64748b;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      
      #playBtn.playing {
        background: rgba(16, 185, 129, 0.2);
        border: 1px solid rgba(16, 185, 129, 0.4);
        color: #6ee7b7;
        box-shadow: none;
        cursor: default;
        pointer-events: none;
        padding: 14px 20px;
        font-size: 14px;
        letter-spacing: 1px;
      }
      
      .btn-challenge {
        width: 100%;
        padding: 14px 20px;
        background: linear-gradient(135deg, #ec4899 0%, #8b5cf6 100%);
        border: none;
        border-radius: 10px;
        color: white;
        font-family: 'Outfit', sans-serif;
        font-size: 14px;
        font-weight: 700;
        letter-spacing: 1px;
        text-transform: uppercase;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(236, 72, 153, 0.3);
        transition: all 0.2s ease;
      }
      
      .btn-challenge:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(236, 72, 153, 0.4);
      }
      
      .btn-challenge:disabled {
        background: #334155;
        box-shadow: none;
        cursor: not-allowed;
        transform: none;
      }
      
      .btn-quit {
        width: 100%;
        padding: 14px 20px;
        background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
        border: none;
        border-radius: 10px;
        color: white;
        font-family: 'Outfit', sans-serif;
        font-size: 14px;
        font-weight: 700;
        letter-spacing: 1px;
        text-transform: uppercase;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(220, 38, 38, 0.3);
        transition: all 0.2s ease;
        margin-top: 10px;
      }
      
      .btn-quit:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(220, 38, 38, 0.4);
      }
      
      .waiting-state {
        text-align: center;
        padding: 8px 0;
      }
      
      .waiting-text {
        font-size: 13px;
        color: var(--text-main);
        margin-bottom: 8px;
      }
      
      .waiting-subtext {
        font-size: 11px;
        color: var(--success);
        margin-bottom: 12px;
      }
      
      .btn-leave {
        width: 100%;
        padding: 10px;
        background: transparent;
        border: 1px solid rgba(239, 68, 68, 0.3);
        border-radius: 8px;
        color: #fca5a5;
        font-weight: 600;
        font-size: 11px;
        transition: all 0.2s;
        text-transform: uppercase;
      }
      
      .btn-leave:hover {
        background: rgba(239, 68, 68, 0.1);
        color: #f87171;
        border-color: rgba(239, 68, 68, 0.4);
      }
      
      /* Action Buttons (Copy/Share) */
      .header-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid var(--glass-border);
        color: white;
        font-family: 'Outfit', sans-serif;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        font-size: 13px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
        backdrop-filter: blur(4px);
      }
      
      .header-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      }
      
      .header-btn:active {
        transform: translateY(0);
      }

      /* Share Input */
      #shareLinkInput {
        background: rgba(0, 0, 0, 0.4) !important;
        border: 1px solid var(--glass-border) !important;
        color: #e2e8f0 !important;
        font-family: 'Inter', sans-serif;
        font-size: 13px !important;
        padding: 10px 12px !important;
        border-radius: 8px !important;
        transition: all 0.2s;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
      }
      
      #shareLinkInput:focus {
        border-color: var(--primary) !important;
        outline: none;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.3), 0 0 0 2px rgba(99, 102, 241, 0.2);
      }
      
      .controls-info {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid var(--glass-border);
        text-align: center;
        font-size: 11px;
        color: #64748b;
        line-height: 1.6;
      }
      
      /* Hidden helper input for match code */
      #matchCode {
        display: none;
      }
      
      /* Game Code Display */
      .game-code-display {
        text-align: center;
        margin-bottom: 12px;
      }
      
      .game-code-label {
        font-size: 11px;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 4px;
      }
      
      .game-code-value {
        font-family: 'Outfit', monospace;
        font-size: 28px;
        font-weight: 700;
        color: var(--accent);
        letter-spacing: 4px;
      }
      
      /* Join with Code */
      .join-code-container {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid var(--glass-border);
      }
      
      .join-code-toggle {
        width: 100%;
        padding: 10px;
        background: transparent;
        border: 1px dashed var(--glass-border);
        border-radius: 8px;
        color: var(--text-muted);
        font-family: 'Inter', sans-serif;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .join-code-toggle:hover {
        border-color: var(--primary);
        color: var(--text-main);
      }
      
      .join-code-form {
        display: none;
        flex-direction: column;
        gap: 8px;
      }
      
      .join-code-form.show {
        display: flex;
      }
      
      .join-code-input {
        width: 100%;
        padding: 12px;
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid var(--glass-border);
        border-radius: 8px;
        color: var(--text-main);
        font-family: 'Outfit', monospace;
        font-size: 20px;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 4px;
      }
      
      .join-code-input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
      }
      
      .join-code-input::placeholder {
        color: var(--text-muted);
        opacity: 0.5;
        letter-spacing: 2px;
        font-size: 14px;
      }
      
      .btn-join {
        width: 100%;
        padding: 12px;
        background: var(--success);
        border: none;
        border-radius: 8px;
        color: white;
        font-family: 'Outfit', sans-serif;
        font-size: 14px;
        font-weight: 700;
        letter-spacing: 1px;
        text-transform: uppercase;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .btn-join:hover {
        background: #0d9669;
        transform: translateY(-1px);
      }
      
      .btn-join:disabled {
        background: #334155;
        cursor: not-allowed;
        transform: none;
      }
      
      /* Game code row with inline buttons */
      .game-code-row {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
      }
      
      /* Icon buttons */
      .btn-icon {
        width: 40px;
        height: 40px;
        border-radius: 10px;
        border: 1px solid var(--glass-border);
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-main);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }
      
      .btn-icon:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-1px);
      }
      
      .btn-icon:active {
        transform: translateY(0);
      }
      
      .btn-icon-primary {
        background: var(--primary);
        border-color: var(--primary);
      }
      
      .btn-icon-primary:hover {
        background: var(--primary-hover);
      }

        /* Ko-fi Button */
      .share-container {
          background: rgba(0, 0, 0, 0.2);
          border-radius: 12px;
          padding: 16px;
          margin: 10px 0;
          border: 1px solid var(--glass-border);
          display: flex;
          flex-direction: column;
          gap: 12px;
      }

      .share-row {
        display: flex;
        gap: 10px;
        width: 100%;
        justify-content: center;
      }
      
      /* Style input to look like a text label */
      #shareLinkInput {
        width: 100%;
        background: transparent !important;
        border: none !important;
        color: var(--text-muted) !important;
        font-family: 'Outfit', sans-serif !important;
        font-size: 11px !important;
        text-align: center;
        padding: 0 !important;
        height: auto !important;
        margin: 0 !important;
        outline: none !important;
        box-shadow: none !important;
        opacity: 0.7;
        pointer-events: none; /* Make it feel like static text */
      }
      
      .btn-copy, .btn-share {
        flex: 1;
        padding: 0 20px;
        height: 48px; /* Taller, easier to hit */
        border-radius: 10px;
        font-family: 'Outfit', sans-serif;
        font-weight: 800;
        font-size: 14px;
        text-transform: uppercase;
        border: none;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        letter-spacing: 0.5px;
      }

      .btn-copy {
          background: var(--glass-border);
          border: 1px solid rgba(255,255,255,0.1);
      }
      
      .btn-copy:hover {
          background: rgba(255,255,255,0.15);
      }

      .btn-share {
          background: var(--primary);
          box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
      }
      
      .btn-share:hover {
          background: var(--primary-hover);
          transform: translateY(-1px);
      }

      /* Cancel Button Polish */
      .btn-leave {
        width: 100%;
        padding: 12px;
        background: rgba(239, 68, 68, 0.1);
        border: 1px solid rgba(239, 68, 68, 0.3);
        border-radius: 10px;
        color: #fca5a5;
        font-family: 'Outfit', sans-serif;
        font-weight: 700;
        font-size: 12px;
        letter-spacing: 1px;
        transition: all 0.2s;
        text-transform: uppercase;
        margin-top: 8px;
      }
      
      .btn-leave:hover {
        background: rgba(239, 68, 68, 0.2);
        border-color: rgba(239, 68, 68, 0.5);
        color: white;
      }

        /* Game Title */
        .game-title {
            font-family: 'Outfit', sans-serif;
            font-weight: 900;
            font-size: 56px; /* Reduced from 80px */
            letter-spacing: 8px;
            background: linear-gradient(to bottom, #fff 40%, #94a3b8 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(99, 102, 241, 0.4);
            margin-bottom: 5px;
            z-index: 10;
            position: relative;
            pointer-events: none;
            text-transform: uppercase;
        }

      /* Mobile touch buttons - subtle design for side panel */
      .touch-controls {
        display: none; /* Hidden by default, shown on mobile */
        flex-direction: column;
        gap: 8px;
        padding: 5px;
        align-items: center;
        justify-content: center;
      }
      
      .touch-btn {
        width: 40px;
        height: 80px; /* Taller for easier pressing */
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        background: rgba(99, 102, 241, 0.2);
        color: rgba(255, 255, 255, 0.7);
        font-size: 18px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        touch-action: manipulation;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
        cursor: pointer;
        transition: background 0.1s, transform 0.1s;
      }
      
      .touch-btn:active, .touch-btn.pressed {
        background: rgba(99, 102, 241, 0.5);
        color: white;
        transform: scale(0.95);
      }
      
      /* Show touch controls on mobile */
      @media (max-width: 850px) {
        #sidePanel {
          flex-direction: row !important;
          align-items: stretch;
        }
        
        .touch-controls {
          display: flex !important;
        }
        
        .panel-card {
          flex: 1;
        }
        
        .controls-info {
          display: none;
        }
      }
      
      /* Mobile Layout */
      @media (max-width: 850px) {
        body {
          align-items: center; 
          overflow: hidden; 
        }
        
        /* Smaller title on mobile */
        .game-title {
            font-size: 24px;
            letter-spacing: 3px;
            margin-bottom: 5px;
            text-shadow: 0 0 15px rgba(99, 102, 241, 0.3);
        }

        #mainContainer {
          flex-direction: column;
          align-items: center;
          justify-content: flex-start;
          gap: 8px;
          height: 100dvh;
          max-height: 100dvh;
          overflow: hidden;
          padding: 5px 0;
        }
        
        .share-row {
           flex-wrap: wrap;
        }
        
        .share-row input {
           flex-basis: 100%;
           margin-bottom: 4px;
        }
        
        .share-row button {
           flex: 1;
        }
        
        #sidePanel {
          width: 95%;
          max-width: 360px;
          order: 2;
          margin-bottom: 5px;
          flex-shrink: 1;
          min-height: 0;
          overflow: hidden;
        }
        
        /* Compact Card for Mobile */
        .panel-card {
            padding: 10px; 
            gap: 6px;
            background: rgba(30, 41, 59, 0.85);
            backdrop-filter: blur(10px);
        }

        /* Compact Score */
        #score {
            font-size: 32px;
        }
        
        #scoreContainer {
            margin-bottom: 0;
        }
        
        #winCondition {
            font-size: 9px;
            margin-bottom: 4px;
            margin-top: 2px;
        }
        
        /* Hide metrics and controls on mobile to save space */
        #metrics, .controls-info {
            display: none;
        }

        /* Compact buttons */
        #playBtn {
             font-size: 14px;
             padding: 10px;
        }
        
        .btn-challenge {
          font-size: 11px;
          padding: 8px 14px;
        }
        
        .btn-quit, .btn-leave {
          padding: 8px;
          font-size: 11px;
        }

        #gameContainer {
          order: 1;
          width: calc(100% - 10px);
          max-width: none;
          flex-shrink: 0;
          flex-grow: 0; /* Don't grow - keep fixed size */
          min-height: 0;
          padding: 0;
          margin: 5px;
          display: flex;
          align-items: center;
          justify-content: center;
          border: 1px solid var(--glass-border);
          border-radius: 12px;
          box-shadow: var(--shadow-lg);
          background: linear-gradient(145deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
          overflow: visible;
          /* Use 16:10 aspect ratio to reduce dead space */
          aspect-ratio: 16 / 10;
          max-height: 50vh; /* Limit height to leave room for controls */
        }
        
        #canvas {
           width: 100%;
           height: 100%;
           object-fit: contain;
           border-radius: 0;
        }
        
        /* Mobile-specific join code styling */
        .join-code-container {
          margin-top: 8px;
          padding-top: 8px;
        }
        
        .join-code-input {
          font-size: 16px;
          padding: 10px;
        }
        
        .game-code-value {
          font-size: 24px;
        }

        /* Hide old buttons if present */
        .mobile-btn {
           display: none !important;
        }
      }
    </style>
  </head>
  <body>
    <h1 class="game-title">PONGO</h1>
    <div id="mainContainer">
      <!-- Game Area -->
      <div id="gameContainer">
        <canvas id="canvas" width="640" height="480"></canvas>

        <div id="countdown"></div>
        <div id="victoryOverlay">
          <div id="victoryText">VICTORY</div>
          <div class="victory-buttons">
            <button id="playAgainBtn">Play Again</button>
            <button id="quitGameBtn" class="btn-quit-overlay">Quit</button>
          </div>
        </div>
      </div>
      
      <!-- Side/Control Panel with Touch Controls -->
      <div id="sidePanel">
        <!-- Mobile Touch Controls - Left Side -->
        <div class="touch-controls left">
          <button class="touch-btn" data-dir="up">▲</button>
          <button class="touch-btn" data-dir="down">▼</button>
        </div>
        
        <!-- Single Control Card -->
        <div class="panel-card">
          <div id="scoreRow">
            <div id="scoreContainer">
              <div id="score">0 : 0</div>
            </div>
            <div id="winCondition">First to 5 Wins</div>
          </div>
          
          <div id="metrics">
            <div class="metric-row">
              <span class="metric-label">FPS</span>
              <span class="metric-value" id="fps">--</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">PING</span>
              <span class="metric-value" id="ping">--</span>
              <span style="font-size: 10px; margin-left: 2px;">ms</span>
            </div>
          </div>
          
          <button id="playBtn" disabled>Play Now</button>
          
          <!-- Hidden input to store match code -->
          <input type="text" id="matchCode" maxlength="5" />
          
          <!-- Multiplayer: Create match button -->
          <div id="lobbyControls">
            <button id="createBtn" class="btn-challenge">Challenge a Friend</button>
            
            <!-- Join with Code -->
            <div class="join-code-container">
              <button id="joinCodeToggle" class="join-code-toggle">Join with Code</button>
              <div id="joinCodeForm" class="join-code-form">
                <input type="text" id="joinCodeInput" class="join-code-input" placeholder="XXXXX" maxlength="5" autocomplete="off" autocapitalize="characters" />
                <button id="joinCodeBtn" class="btn-join" disabled>Join Game</button>
              </div>
            </div>
          </div>
          
          <!-- Quit button for local games -->
          <button id="quitBtn" class="btn-quit" style="display: none;">Quit Game</button>
          <!-- Waiting for opponent -->
          <div id="activeMatchControls" style="display: none;">
            <div class="waiting-state">
              <!-- Game Code Display with inline buttons -->
              <div class="game-code-display">
                <div class="game-code-label">Game Code</div>
                <div class="game-code-row">
                  <div id="gameCodeDisplay" class="game-code-value">-----</div>
                  <button id="copyCodeBtn" class="btn-icon" title="Copy Code">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                  </button>
                  <button id="shareLinkBtn" class="btn-icon btn-icon-primary" title="Share" style="display: none;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <circle cx="18" cy="5" r="3"></circle>
                      <circle cx="6" cy="12" r="3"></circle>
                      <circle cx="18" cy="19" r="3"></circle>
                      <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                      <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                    </svg>
                  </button>
                </div>
              </div>
              
              <!-- Hidden input to store share link -->
              <input type="text" id="shareLinkInput" readonly style="display: none;">

              <div id="copyFeedback" style="font-size: 12px; font-weight: 600; min-height: 18px; display: flex; align-items: center; justify-content: center; color: var(--accent);"></div>
              
              <button id="leaveBtn" class="btn-leave">Cancel</button>
            </div>
          </div>
          
          <div class="controls-info">
            CONTROLS<br>
            W / S or ↑ / ↓ to Move
          </div>
          
          <!-- Ko-fi Support Button -->
          <div style="margin-top: 10px; display: flex; justify-content: center;">
            <a href="https://ko-fi.com/N4N31DPNUS" target="_blank" rel="noopener noreferrer">
              <img height="34" style="border:0px;height:34px;" src="https://storage.ko-fi.com/cdn/kofi2.png?v=6" alt="Buy Me a Coffee at ko-fi.com" />
            </a>
          </div>
        </div>
        
        <!-- Mobile Touch Controls - Right Side -->
        <div class="touch-controls right">
          <button class="touch-btn" data-dir="up">▲</button>
          <button class="touch-btn" data-dir="down">▼</button>
        </div>
      </div>
    </div>

    <!-- JS Logic -->
    <script type="module">
      // Sound effects using Web Audio API
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      let audioCtx = null;

      function initAudio() {
        if (!audioCtx) {
          audioCtx = new AudioContext();
        }
      }

      function playSound(type) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        switch (type) {
          case "paddle":
            osc.frequency.setValueAtTime(440, audioCtx.currentTime);
            osc.type = "sine";
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
            break;
          case "wall":
            osc.frequency.setValueAtTime(220, audioCtx.currentTime);
            osc.type = "sine";
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.08);
            break;
          case "score":
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.2);
            osc.type = "triangle";
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
            break;
          case "victory":
            [0, 0.15, 0.3].forEach((delay, i) => {
              const o = audioCtx.createOscillator();
              const g = audioCtx.createGain();
              o.connect(g);
              g.connect(audioCtx.destination);
              o.frequency.setValueAtTime([523, 659, 784][i], audioCtx.currentTime + delay);
              o.type = "triangle";
              g.gain.setValueAtTime(0.1, audioCtx.currentTime + delay);
              g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + delay + 0.3);
              o.start(audioCtx.currentTime + delay);
              o.stop(audioCtx.currentTime + delay + 0.3);
            });
            break;
        }
      }

      const CACHE_BUST = new URLSearchParams(window.location.search).get("v") || Date.now();
      const wasmUrl = "/client_wasm/client_wasm.js?v=" + CACHE_BUST;

      let init, WasmClient, GameFsm, FsmState;
      try {
        const module = await import(wasmUrl);
        init = module.default;
        WasmClient = module.WasmClient;
        GameFsm = module.GameFsm;
        FsmState = module.FsmState;
        
        // Initialize WASM before using any exports
        await init();
      } catch (error) {
        console.error("Failed to load WASM:", error);
        document.getElementById("status").textContent = "Failed to load game resource";
        throw error;
      }

      let client = null;
      let ws = null;
      let lastScore = [0, 0];
      let renderLoopId = null;
      let pingIntervalId = null;
      let inputIntervalId = null;
      let currentMatchCode = null;

      // ========================================
      // Finite State Machine (Rust-backed)
      // ========================================
      // Map Rust FsmState enum to string names for compatibility
      const GameState = {
        IDLE: FsmState.Idle,
        COUNTDOWN_LOCAL: FsmState.CountdownLocal,
        PLAYING_LOCAL: FsmState.PlayingLocal,
        CONNECTING: FsmState.Connecting,
        WAITING: FsmState.Waiting,
        COUNTDOWN_MULTI: FsmState.CountdownMulti,
        PLAYING_MULTI: FsmState.PlayingMulti,
        GAME_OVER_LOCAL: FsmState.GameOverLocal,
        GAME_OVER_MULTI: FsmState.GameOverMulti,
        DISCONNECTED: FsmState.Disconnected
      };

      // Create Rust FSM instance (after init())
      const rustFsm = new GameFsm();

      // Wrapper that maintains same API but uses Rust FSM
      const FSM = {
        get state() {
          return rustFsm.state;
        },

        canTransition(action) {
          // Create a temporary action to check
          const tempFsm = new GameFsm();
          // Copy current state (we can't directly, so use transition_str approach)
          // For now, just use the fact that canTransition is not heavily used
          return true; // Simplified - Rust FSM handles invalid transitions gracefully
        },

        async transition(action) {
          const prevState = rustFsm.state;
          const result = rustFsm.transition_str(action);
          
          if (!result.success) {
            console.warn(`Invalid transition: ${rustFsm.state_string()} + ${action}`);
            return false;
          }
          
          console.log(`FSM: ${result.from_state} --[${action}]--> ${result.to_state}`);
          await this.exitState(prevState);
          await this.enterState(rustFsm.state);
          return true;
        },

        async exitState(state) {
          switch (state) {
            case FsmState.PlayingLocal:
            case FsmState.PlayingMulti:
              stopGameLoop();
              break;
            case FsmState.Waiting:
            case FsmState.CountdownMulti:
              stopEventPolling();
              hideCountdownNumber();
              break;
            case FsmState.GameOverMulti:
              stopEventPolling();
              // Fallthrough
            case FsmState.GameOverLocal:
              hideVictoryOverlay();
              break;
            case FsmState.Connecting:
              break;
          }
        },

        async enterState(state) {
          updateUIForState(state);
          switch (state) {
            case FsmState.Idle:
              await enterIdle();
              break;
            case FsmState.CountdownLocal:
              await enterCountdownLocal();
              break;
            case FsmState.PlayingLocal:
              enterPlayingLocal();
              break;
            case FsmState.Connecting:
              await enterConnecting();
              break;
            case FsmState.Waiting:
              enterWaiting();
              break;
            case FsmState.CountdownMulti:
              await enterCountdownMulti();
              break;
            case FsmState.PlayingMulti:
              enterPlayingMulti();
              break;
            case FsmState.GameOverLocal:
            case FsmState.GameOverMulti:
              if (state === FsmState.GameOverMulti) {
                startEventPolling();
              }
              break;
            case FsmState.Disconnected:
              enterDisconnected();
              break;
          }
        }
      };

      // ========================================
      // State Entry Handlers
      // ========================================
      async function enterIdle() {
        closeWebSocket();
        stopGameLoop();
        lastScore = [0, 0];
        currentMatchCode = null;
        
        // Clear URL params
        const url = new URL(window.location);
        if (url.searchParams.has('code')) {
          url.searchParams.delete('code');
          window.history.pushState({}, '', url);
        }
        document.getElementById('matchCode').value = '';
      }

      async function enterCountdownLocal() {
        initAudio();
        const canvas = document.getElementById('canvas');
        if (!client) {
          client = await new WasmClient(canvas);
        }
        await showCountdown();
        FSM.transition('COUNTDOWN_DONE');
      }

      function enterPlayingLocal() {
        client.start_local_game();
        lastScore = [0, 0];
        updateScore(0, 0);
        document.body.classList.add('game-active');
        setupInputIfNeeded();
        startRenderLoop();
      }

      async function enterConnecting() {
        initAudio();
        const canvas = document.getElementById('canvas');
        if (!client) {
          client = await new WasmClient(canvas);
        }
        
        const code = currentMatchCode || document.getElementById('matchCode').value.trim().toUpperCase();
        if (code.length !== 5) {
          FSM.transition('CONNECTION_FAILED');
          return;
        }
        currentMatchCode = code;
        
        // Update URL
        const url = new URL(window.location);
        if (url.searchParams.get('code') !== code) {
          url.searchParams.set('code', code);
          window.history.pushState({}, '', url);
        }
        
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws/${code}`;
        
        try {
          ws = new WebSocket(wsUrl);
          ws.binaryType = 'arraybuffer';
          
          ws.onopen = () => {
            try {
              ws.send(client.get_join_bytes(code));
              FSM.transition('CONNECTED');
            } catch (e) {
              console.error('Join error:', e);
              FSM.transition('CONNECTION_FAILED');
            }
          };
          
          ws.onmessage = (event) => {
            if (event.data instanceof ArrayBuffer) {
              try {
                client.on_message(new Uint8Array(event.data));
                
                // Poll for match events from server
                const matchEvent = client.get_match_event();
                if (matchEvent) {
                  handleMatchEvent(matchEvent);
                }
                
                // Update score if playing
                if (FSM.state === GameState.PLAYING_MULTI) {
                  const score = client.get_score();
                  if (score.length >= 2) {
                    updateScore(score[0], score[1]);
                  }
                }
              } catch (e) { console.error('Message error:', e); }
            }
          };
          
          ws.onerror = () => {
            if (FSM.state === GameState.CONNECTING) {
              FSM.transition('CONNECTION_FAILED');
            }
          };
          
          ws.onclose = () => {
            if (FSM.state === GameState.WAITING || FSM.state === GameState.COUNTDOWN_MULTI) {
              FSM.transition('DISCONNECTED');
            } else if (FSM.state === GameState.PLAYING_MULTI || FSM.state === GameState.GAME_OVER_MULTI) {
              FSM.transition('DISCONNECTED');
            } else if (FSM.state === GameState.CONNECTING) {
              FSM.transition('CONNECTION_FAILED');
            }
          };
        } catch (e) {
          FSM.transition('CONNECTION_FAILED');
        }
      }

      function enterWaiting() {
        // Start polling for events while waiting
        startEventPolling();
      }

      async function enterCountdownMulti() {
        // Reset client state for fresh start - critical for rematch smoothness
        if (client) {
          client.reset_for_multiplayer();
        }
        // Server drives the countdown - we just display what it sends
        // The countdown display is handled by handleMatchEvent
        // Wait here until game_start is received
        // (Transition to PLAYING_MULTI is triggered by handleMatchEvent)
      }

      // Handle match events from server
      function handleMatchEvent(event) {
        console.log('Match event:', event, 'State:', FSM.state);
        
        if (event === 'match_found') {
          if (FSM.state === GameState.WAITING) {
            playSound('paddle');
            FSM.transition('OPPONENT_JOINED');
          }
        } else if (event.startsWith('countdown:')) {
          const seconds = parseInt(event.split(':')[1]);
          showCountdownNumber(seconds);
          
          if (FSM.state === GameState.GAME_OVER_MULTI) {
             FSM.transition('REMATCH_STARTED');
          }
        } else if (event === 'game_start') {
          hideCountdownNumber();
          if (FSM.state === GameState.COUNTDOWN_MULTI) {
            FSM.transition('COUNTDOWN_DONE');
          }
        } else if (event === 'opponent_disconnected') {
          // Handle opponent leaving at any multiplayer stage
          if (FSM.state === GameState.WAITING || 
              FSM.state === GameState.COUNTDOWN_MULTI || 
              FSM.state === GameState.PLAYING_MULTI ||
              FSM.state === GameState.GAME_OVER_MULTI) {
            FSM.transition('DISCONNECTED');
          }
        }
      }

      // Show a single countdown number
      function showCountdownNumber(n) {
        const el = document.getElementById('countdown');
        el.textContent = n > 0 ? n.toString() : 'GO!';
        el.classList.add('show');
        playSound('paddle');
        setTimeout(() => el.classList.remove('show'), 800);
      }

      function hideCountdownNumber() {
        document.getElementById('countdown').classList.remove('show');
      }

      let eventPollingId = null;
      function startEventPolling() {
        stopEventPolling();
        eventPollingId = setInterval(() => {
          if (client && ws && ws.readyState === WebSocket.OPEN) {
            const matchEvent = client.get_match_event();
            if (matchEvent) {
              handleMatchEvent(matchEvent);
            }
          }
        }, 100);
      }

      function stopEventPolling() {
        if (eventPollingId) {
          clearInterval(eventPollingId);
          eventPollingId = null;
        }
      }

      function enterPlayingMulti() {
        lastScore = [0, 0];
        document.body.classList.add('game-active');
        setupInputIfNeeded();
        startRenderLoop();
        startPingInterval();
        // Start input polling (must be called every game, not just once)
        if (!inputIntervalId) {
          inputIntervalId = setInterval(sendInput, 33);
        }
      }

      function enterDisconnected() {
        closeWebSocket();
        stopGameLoop();
      }

      // ========================================
      // UI Updates
      // ========================================
      function updateUIForState(state) {
        const playBtn = document.getElementById('playBtn');
        const lobbyControls = document.getElementById('lobbyControls');
        const activeMatchControls = document.getElementById('activeMatchControls');
        const quitBtn = document.getElementById('quitBtn');
        
        switch (state) {
          case GameState.IDLE:
            playBtn.textContent = 'Play Now';
            playBtn.disabled = false;
            playBtn.classList.remove('playing');
            lobbyControls.style.display = 'block';
            activeMatchControls.style.display = 'none';
            quitBtn.style.display = 'none';
            document.body.classList.remove('game-active');
            break;
            
          case GameState.COUNTDOWN_LOCAL:
            playBtn.textContent = 'Starting...';
            playBtn.disabled = true;
            lobbyControls.style.display = 'none';
            quitBtn.style.display = 'block';
            break;
            
          case GameState.PLAYING_LOCAL:
            playBtn.textContent = 'Playing vs AI';
            playBtn.classList.add('playing');
            lobbyControls.style.display = 'none';
            quitBtn.style.display = 'block';
            break;
            
          case GameState.CONNECTING:
            playBtn.textContent = 'Connecting...';
            playBtn.disabled = true;
            lobbyControls.style.display = 'none';
            activeMatchControls.style.display = 'block';
            break;
            
          case GameState.WAITING:
            playBtn.textContent = 'Waiting...';
            break;
            
          case GameState.COUNTDOWN_MULTI:
            playBtn.textContent = 'Get Ready!';
            activeMatchControls.style.display = 'none';
            break;
            
          case GameState.PLAYING_MULTI:
            playBtn.textContent = 'In Match';
            playBtn.classList.add('playing');
            lobbyControls.style.display = 'none';
            activeMatchControls.style.display = 'none';
            break;

          case GameState.GAME_OVER_LOCAL:
          case GameState.GAME_OVER_MULTI:
            playBtn.textContent = 'Game Over';
            playBtn.classList.remove('playing');
            activeMatchControls.style.display = 'none';
            break;
            
          case GameState.DISCONNECTED:
            playBtn.textContent = 'Disconnected';
            playBtn.disabled = false;
            playBtn.classList.remove('playing');
            document.body.classList.remove('game-active');
            break;
        }
      }

      function updateScore(left, right) {
        const el = document.getElementById('score');
        if (el) {
          if (left !== lastScore[0] || right !== lastScore[1]) {
            playSound('score');
            el.classList.add('flash');
            setTimeout(() => el.classList.remove('flash'), 200);
            lastScore = [left, right];
          }
          el.textContent = `${left} : ${right}`;
        }
      }

      function updateMetrics() {
        if (client) {
          try {
            const metrics = client.get_metrics();
            if (metrics.length >= 2) {
              document.getElementById('fps').textContent = Math.round(metrics[0]);
              document.getElementById('ping').textContent = Math.round(metrics[1]);
            }
          } catch (e) {}
        }
      }

      // ========================================
      // Game Loop
      // ========================================
      function startRenderLoop() {
        function render() {
          if (client) {
            try {
              client.render();
              updateMetrics();
              const score = client.get_score();
              if (score.length >= 2) {
                updateScore(score[0], score[1]);
                
                // Check for game over
                const winner = client.get_winner();
                if (winner) {
                  showVictory(winner);
                  FSM.transition('GAME_OVER');
                  return;
                }
                if (score[0] >= 5 || score[1] >= 5) {
                  const winnerName = score[0] >= 5 ? 'you' : 'opponent';
                  showVictory(winnerName);
                  if (FSM.state === GameState.PLAYING_LOCAL) {
                    FSM.transition('GAME_OVER_LOCAL');
                  } else {
                    FSM.transition('GAME_OVER_MULTI');
                  }
                  return;
                }
              }
            } catch (e) {}
          }
          
          if (FSM.state === GameState.PLAYING_LOCAL || FSM.state === GameState.PLAYING_MULTI) {
            renderLoopId = requestAnimationFrame(render);
          }
        }
        render();
      }

      function stopGameLoop() {
        if (renderLoopId) {
          cancelAnimationFrame(renderLoopId);
          renderLoopId = null;
        }
        if (pingIntervalId) {
          clearInterval(pingIntervalId);
          pingIntervalId = null;
        }
        if (inputIntervalId) {
          clearInterval(inputIntervalId);
          inputIntervalId = null;
        }
      }

      function startPingInterval() {
        pingIntervalId = setInterval(() => {
          if (ws && ws.readyState === WebSocket.OPEN && client) {
            try {
              const pingBytes = client.send_ping();
              ws.send(pingBytes);
            } catch (e) {}
          }
        }, 2000);
      }

      // ========================================
      // WebSocket & Input
      // ========================================
      function closeWebSocket() {
        if (ws) {
          ws.close();
          ws = null;
        }
      }

      function sendInput() {
        if (ws && ws.readyState === WebSocket.OPEN && client) {
          try {
            const bytes = client.get_input_bytes();
            if (bytes.length > 0) {
              ws.send(bytes);
            }
          } catch (e) {}
        }
      }

      let inputSetup = false;
      function setupInputIfNeeded() {
        if (inputSetup) return;
        inputSetup = true;
        
        const pressedKeys = new Set();
        window.addEventListener('keydown', (e) => {
          const gameKeys = ['ArrowUp', 'ArrowDown', 'w', 'W', 's', 'S'];
          if (gameKeys.includes(e.key)) {
            e.preventDefault();
            const upKeys = ['ArrowUp', 'w', 'W'];
            const downKeys = ['ArrowDown', 's', 'S'];
            if (upKeys.includes(e.key)) {
              downKeys.forEach(key => {
                if (pressedKeys.has(key)) {
                  pressedKeys.delete(key);
                  if (client) client.handle_key_string(key, false);
                }
              });
              pressedKeys.add(e.key);
            } else if (downKeys.includes(e.key)) {
              upKeys.forEach(key => {
                if (pressedKeys.has(key)) {
                  pressedKeys.delete(key);
                  if (client) client.handle_key_string(key, false);
                }
              });
              pressedKeys.add(e.key);
            }
          }
          if (client) {
            client.on_key_down(e);
            sendInput();
          }
        }, { capture: true, passive: false });

        window.addEventListener('keyup', (e) => {
          const gameKeys = ['ArrowUp', 'ArrowDown', 'w', 'W', 's', 'S'];
          if (gameKeys.includes(e.key)) {
            e.preventDefault();
            pressedKeys.delete(e.key);
          }
          if (client) {
            client.on_key_up(e);
            sendInput();
          }
        }, { capture: true, passive: false });

        // --- Touch Button Controls ---
        let currentTouchDir = 0;
        
        const handleTouchBtnPress = (dir) => {
          if (!client) return;
          
          const newDir = dir === 'up' ? -1 : 1;
          if (newDir !== currentTouchDir) {
            // Release old direction
            if (currentTouchDir === -1) client.handle_key_string('ArrowUp', false);
            if (currentTouchDir === 1) client.handle_key_string('ArrowDown', false);
            
            // Press new direction
            if (newDir === -1) client.handle_key_string('ArrowUp', true);
            if (newDir === 1) client.handle_key_string('ArrowDown', true);
            
            currentTouchDir = newDir;
            sendInput();
          }
        };
        
        const handleTouchBtnRelease = () => {
          if (!client) return;
          
          if (currentTouchDir === -1) client.handle_key_string('ArrowUp', false);
          if (currentTouchDir === 1) client.handle_key_string('ArrowDown', false);
          currentTouchDir = 0;
          sendInput();
        };
        
        // Set up touch button event listeners
        document.querySelectorAll('.touch-btn').forEach(btn => {
          const dir = btn.dataset.dir;
          
          btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            btn.classList.add('pressed');
            handleTouchBtnPress(dir);
          }, { passive: false });
          
          btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            btn.classList.remove('pressed');
            handleTouchBtnRelease();
          }, { passive: false });
          
          btn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            btn.classList.remove('pressed');
            handleTouchBtnRelease();
          }, { passive: false });
          
          // Also support mouse for testing on desktop
          btn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            btn.classList.add('pressed');
            handleTouchBtnPress(dir);
          });
          
          btn.addEventListener('mouseup', (e) => {
            e.preventDefault();
            btn.classList.remove('pressed');
            handleTouchBtnRelease();
          });
          
          btn.addEventListener('mouseleave', () => {
            if (btn.classList.contains('pressed')) {
              btn.classList.remove('pressed');
              handleTouchBtnRelease();
            }
          });
        });
      }

      // ========================================
      // Victory/Countdown Overlays
      // ========================================
      async function showCountdown() {
        const el = document.getElementById('countdown');
        for (const text of ['3', '2', '1', 'GO!']) {
          el.textContent = text;
          el.classList.add('show');
          playSound('paddle');
          await new Promise(r => setTimeout(r, 600));
          el.classList.remove('show');
          await new Promise(r => setTimeout(r, 100));
        }
      }

      function showVictory(winner) {
        playSound('victory');
        const overlay = document.getElementById('victoryOverlay');
        const text = document.getElementById('victoryText');
        
        if (winner === 'you') {
          text.textContent = 'VICTORY';
          text.className = 'status-win';
        } else {
          text.textContent = 'DEFEAT';
          text.className = 'status-lose';
        }
        
        // Reset button
        const btn = document.getElementById('playAgainBtn');
        btn.textContent = 'Play Again';
        btn.disabled = false;
        
        overlay.classList.add('show');
        document.body.classList.remove('game-active');
      }

      function hideVictoryOverlay() {
        document.getElementById('victoryOverlay').classList.remove('show');
      }

      // ========================================
      // Public API / Event Handlers
      // ========================================
      window.startLocalGame = async function() {
        if (FSM.state === GameState.IDLE) {
          await FSM.transition('START_LOCAL');
        } else if (FSM.state === GameState.GAME_OVER_LOCAL) {
          await FSM.transition('PLAY_AGAIN');
        }
      };

      window.createMatch = async function() {
        if (FSM.state !== GameState.IDLE) return;
        try {
          const response = await fetch('/create');
          const data = await response.json();
          document.getElementById('matchCode').value = data.code;
          currentMatchCode = data.code;
          
          // Display game code prominently
          const codeDisplay = document.getElementById('gameCodeDisplay');
          if (codeDisplay) {
            codeDisplay.textContent = data.code;
          }
          
          // Build and copy invite URL
          const url = new URL(window.location);
          url.searchParams.set('code', data.code);
          const linkStr = url.toString();
          
          document.getElementById('shareLinkInput').value = linkStr;
          const feedback = document.getElementById('copyFeedback');
          
          try {
            await navigator.clipboard.writeText(linkStr);
            feedback.textContent = 'LINK COPIED TO CLIPBOARD';
            feedback.style.color = 'var(--accent)';
          } catch (e) {
            console.warn('Could not copy to clipboard:', e);
            feedback.textContent = 'Share the code above';
            feedback.style.color = 'var(--text-muted)';
          }
          
          await FSM.transition('CREATE_MATCH');
        } catch (e) {
          console.error('Create match error:', e);
        }
      };
      
      // Copy code button handler
      document.getElementById('copyCodeBtn').addEventListener('click', async () => {
        const code = document.getElementById('gameCodeDisplay').textContent;
        const feedback = document.getElementById('copyFeedback');
        try {
          await navigator.clipboard.writeText(code);
          feedback.textContent = '✓ Code copied!';
        } catch (e) {
          // Fallback - copy the full link instead
          const link = document.getElementById('shareLinkInput').value;
          await navigator.clipboard.writeText(link);
          feedback.textContent = '✓ Link copied!';
        }
        // Clear feedback after 2 seconds
        setTimeout(() => { feedback.textContent = ''; }, 2000);
      });

      // Native Share API handler
      if (navigator.share) {
        document.getElementById('shareLinkBtn').style.display = 'flex';
      }
      
      document.getElementById('shareLinkBtn').addEventListener('click', async () => {
        const link = document.getElementById('shareLinkInput').value;
        try {
          await navigator.share({
            title: 'Lets Play Pong!',
            text: 'Join me for a match of Pong!',
            url: link
          });
        } catch (err) {
          console.error('Share failed:', err);
        }
      });

      // Join with Code handlers
      document.getElementById('joinCodeToggle').addEventListener('click', () => {
        const toggle = document.getElementById('joinCodeToggle');
        const form = document.getElementById('joinCodeForm');
        
        if (form.classList.contains('show')) {
          form.classList.remove('show');
          toggle.textContent = 'Join with Code';
        } else {
          form.classList.add('show');
          toggle.textContent = 'Cancel';
          document.getElementById('joinCodeInput').focus();
        }
      });
      
      document.getElementById('joinCodeInput').addEventListener('input', (e) => {
        const value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
        e.target.value = value;
        document.getElementById('joinCodeBtn').disabled = value.length !== 5;
      });
      
      document.getElementById('joinCodeBtn').addEventListener('click', () => {
        const code = document.getElementById('joinCodeInput').value.trim().toUpperCase();
        if (code.length === 5) {
          // Navigate to the URL with the code parameter
          const url = new URL(window.location);
          url.searchParams.set('code', code);
          window.location.href = url.toString();
        }
      });
      
      // Allow Enter key to submit the code
      document.getElementById('joinCodeInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const code = e.target.value.trim().toUpperCase();
          if (code.length === 5) {
            const url = new URL(window.location);
            url.searchParams.set('code', code);
            window.location.href = url.toString();
          }
        }
      });

      window.joinMatch = async function() {
        if (FSM.state !== GameState.IDLE) return;
        const code = document.getElementById('matchCode').value.trim().toUpperCase();
        if (code.length !== 5) return;
        currentMatchCode = code;
        await FSM.transition('JOIN_MATCH');
      };

      window.leaveGame = function() {
        if (FSM.canTransition('LEAVE')) {
          FSM.transition('LEAVE');
        }
      };

      // ========================================
      // Initialization
      // ========================================
      document.getElementById('playAgainBtn').addEventListener('click', () => {
        if (FSM.state === GameState.GAME_OVER_LOCAL) {
          FSM.transition('PLAY_AGAIN');
        } else if (FSM.state === GameState.GAME_OVER_MULTI) {
          // Send restart request
          if (client && ws && ws.readyState === WebSocket.OPEN) {
              try {
                  const bytes = client.get_restart_bytes();
                  ws.send(bytes);
                  // Immediate reset for better UX
                  client.reset_local_state();
                  hideVictoryOverlay();
              } catch (e) { console.error(e); }
          }
        }
      });

      document.getElementById('leaveBtn').addEventListener('click', () => {
        window.leaveGame();
      });

      async function main() {
        try {
          // WASM already initialized after import
          document.getElementById('playBtn').disabled = false;
          document.getElementById('playBtn').addEventListener('click', window.startLocalGame);
          document.getElementById('createBtn').addEventListener('click', window.createMatch);
          document.getElementById('quitBtn').addEventListener('click', () => {
            // Stop the local game and return to idle
            stopGameLoop();
            if (client) {
              client.stop_local_game();
            }
            FSM.transition('QUIT');
          });
          
          document.getElementById('quitGameBtn').addEventListener('click', async () => {
            // Close WebSocket connection and return to idle
            closeWebSocket();
            stopGameLoop();
            hideVictoryOverlay();
            await FSM.transition('LEAVE');
          });

          // Auto-join if code in URL
          const urlParams = new URLSearchParams(window.location.search);
          const code = urlParams.get('code');
          if (code) {
            document.getElementById('matchCode').value = code;
            currentMatchCode = code;
            await FSM.transition('JOIN_MATCH');
          }
        } catch (error) {
          console.error('Init error:', error);
        }
      }

      main().catch((error) => {
        console.error('Fatal error:', error);
      });
    </script>
  </body>
</html>
