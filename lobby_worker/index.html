<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pong</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Outfit:wght@700;900&display=swap" rel="stylesheet">
    
    <style>
      :root {
        --bg-dark: #0f172a;
        --bg-deep: #020617;
        --primary: #6366f1;
        --primary-hover: #4f46e5;
        --secondary: #ec4899;
        --accent: #06b6d4;
        --success: #10b981;
        --danger: #ef4444;
        
        --text-main: #f8fafc;
        --text-muted: #94a3b8;
        
        --glass-bg: rgba(30, 41, 59, 0.6);
        --glass-border: rgba(255, 255, 255, 0.08);
        --glass-shine: rgba(255, 255, 255, 0.05);
        
        --shadow-sm: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
        --glow-primary: 0 0 25px rgba(99, 102, 241, 0.25);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 20px;
        min-height: 100vh;
        background: radial-gradient(circle at top center, #1e293b 0%, #020617 100%);
        color: var(--text-main);
        font-family: 'Inter', sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        overflow-x: hidden;
      }

      /* Subtle animated grid background */
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        background-image: 
          linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
          linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
        background-size: 50px 50px;
        pointer-events: none;
        z-index: 0;
        mask-image: radial-gradient(circle at center, black 40%, transparent 100%);
      }

      #mainContainer {
        display: flex;
        flex-direction: row;
        align-items: flex-start;
        justify-content: center;
        gap: 40px;
        width: 100%;
        max-width: 1100px;
        position: relative;
        z-index: 1;
      }

      #gameContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        border-radius: 20px;
        padding: 6px;
        background: linear-gradient(145deg, rgba(255,255,255,0.05), rgba(255,255,255,0.01));
        box-shadow: var(--shadow-lg), var(--glow-primary);
        border: 1px solid var(--glass-border);
      }

      #canvas {
        display: block;
        max-width: 100%;
        background: #000;
        border-radius: 14px;
        touch-action: none;
      }

      /* Countdown overlay */
      #countdown {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: 'Outfit', sans-serif;
        font-size: 140px;
        font-weight: 900;
        color: white;
        text-shadow: 0 0 40px var(--primary);
        z-index: 100;
        opacity: 0;
        transition: opacity 0.2s, transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        pointer-events: none;
      }

      #countdown.show {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1);
      }

      /* Victory overlay */
      #victoryOverlay {
        position: absolute;
        inset: 0;
        background: rgba(2, 6, 23, 0.85);
        backdrop-filter: blur(12px);
        border-radius: 14px;
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 200;
        opacity: 0;
        transition: opacity 0.4s ease;
      }

      #victoryOverlay.show {
        display: flex;
        opacity: 1;
      }

      #victoryText {
        font-family: 'Outfit', sans-serif;
        font-size: 64px;
        font-weight: 800;
        margin-bottom: 30px;
        text-align: center;
        letter-spacing: -1px;
      }
      
      .status-win {
        background: linear-gradient(to right, #4ade80, #3b82f6);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 0 30px rgba(74, 222, 128, 0.3);
      }
      
      .status-lose {
        background: linear-gradient(to right, #f472b6, #ef4444);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 0 30px rgba(239, 68, 68, 0.3);
      }

      #playAgainBtn {
        padding: 16px 40px;
        font-size: 18px;
        font-weight: 700;
        font-family: 'Outfit', sans-serif;
        letter-spacing: 1px;
        color: white;
        background: var(--primary);
        border: none;
        border-radius: 100px;
        cursor: pointer;
        box-shadow: 0 10px 20px -5px rgba(99, 102, 241, 0.4);
        transition: all 0.2s ease;
        text-transform: uppercase;
      }

      #playAgainBtn:hover {
        transform: translateY(-2px);
        background: var(--primary-hover);
        box-shadow: 0 15px 25px -5px rgba(99, 102, 241, 0.5);
      }

      /* Side Panel */
      #sidePanel {
        display: flex;
        flex-direction: column;
        gap: 20px;
        width: 320px;
        flex-shrink: 0;
      }

      /* Card Style */
      .panel-card {
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        border-radius: 16px;
        padding: 24px;
        box-shadow: var(--shadow-sm);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      /* Score Section */
      #scoreContainer {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        width: 100%;
      }

      #score {
        font-family: 'Outfit', sans-serif;
        font-size: 56px;
        font-weight: 800;
        color: white;
        margin: 0;
        text-align: center;
        letter-spacing: -1px;
        line-height: 1;
        transition: transform 0.1s cubic-bezier(0.4, 0, 0.2, 1);
      }

      #score.flash {
        transform: scale(1.15);
        color: var(--accent);
        text-shadow: 0 0 20px rgba(6, 182, 212, 0.5);
      }
      
      #winCondition {
        text-align: center;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--text-muted);
        font-weight: 600;
        margin-top: 4px;
      }

      /* Metrics */
      #metrics {
        display: flex;
        justify-content: center;
        gap: 16px;
        padding: 0;
        background: transparent;
        border: none;
        box-shadow: none;
        opacity: 0.6;
        transition: opacity 0.2s;
      }
      
      #metrics:hover { opacity: 1; }

      .metric-row {
        display: flex;
        align-items: center;
        font-size: 12px;
        color: var(--text-muted);
        font-variant-numeric: tabular-nums;
      }
      
      .metric-label { margin-right: 6px; }
      .metric-value { font-weight: 600; color: var(--text-main); }

      /* UI Controls */
      #playBtn {
        width: 100%;
        padding: 20px;
        font-family: 'Outfit', sans-serif;
        font-size: 20px;
        font-weight: 700;
        letter-spacing: 2px;
        text-transform: uppercase;
        background: linear-gradient(135deg, var(--primary) 0%, #4f46e5 100%);
        border: none;
        color: white;
        border-radius: 12px;
        cursor: pointer;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1), 0 10px 15px -3px rgba(99, 102, 241, 0.3);
        transition: all 0.2s ease;
      }
      
      #playBtn:hover {
        transform: translateY(-2px);
        filter: brightness(1.1);
        box-shadow: 0 20px 25px -5px rgba(99, 102, 241, 0.4);
      }
      
      #playBtn:disabled {
        background: #334155;
        color: #64748b;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      
      #playBtn.playing {
        background: rgba(16, 185, 129, 0.2);
        border: 1px solid rgba(16, 185, 129, 0.4);
        color: #6ee7b7;
        box-shadow: none;
        cursor: default;
        pointer-events: none;
        padding: 14px 20px;
        font-size: 14px;
        letter-spacing: 1px;
      }
      
      .btn-challenge {
        width: 100%;
        padding: 14px 20px;
        background: linear-gradient(135deg, #ec4899 0%, #8b5cf6 100%);
        border: none;
        border-radius: 10px;
        color: white;
        font-family: 'Outfit', sans-serif;
        font-size: 14px;
        font-weight: 700;
        letter-spacing: 1px;
        text-transform: uppercase;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(236, 72, 153, 0.3);
        transition: all 0.2s ease;
      }
      
      .btn-challenge:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(236, 72, 153, 0.4);
      }
      
      .btn-challenge:disabled {
        background: #334155;
        box-shadow: none;
        cursor: not-allowed;
        transform: none;
      }
      
      .waiting-state {
        text-align: center;
        padding: 8px 0;
      }
      
      .waiting-text {
        font-size: 13px;
        color: var(--text-main);
        margin-bottom: 8px;
      }
      
      .waiting-subtext {
        font-size: 11px;
        color: var(--success);
        margin-bottom: 12px;
      }
      
      .btn-leave {
        width: 100%;
        padding: 10px;
        background: transparent;
        border: 1px solid rgba(239, 68, 68, 0.3);
        border-radius: 8px;
        color: #fca5a5;
        font-weight: 600;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
      }
      
      .btn-leave:hover {
        background: rgba(239, 68, 68, 0.1);
        color: #f87171;
      }
      
      .controls-info {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid var(--glass-border);
        text-align: center;
        font-size: 11px;
        color: #64748b;
        line-height: 1.6;
      }
      
      /* Hidden helper input for match code */
      #matchCode {
        display: none;
      }

      .mobile-btn {
        display: none;
      }

      /* Mobile Layout */
      @media (max-width: 850px) {
        #mainContainer {
          flex-direction: column;
          align-items: center;
          gap: 20px;
        }
        
        #sidePanel {
          width: 100%;
          order: 2;
        }
        
        #gameContainer {
          order: 1;
        }
        
        /* Mobile: spread buttons to edges */
        #scoreContainer {
          width: 100%;
          justify-content: space-between;
          padding: 0 8px;
        }
        
        /* Mobile Touch Buttons */
        .mobile-btn {
           display: flex;
           align-items: center;
           justify-content: center;
           background: rgba(255,255,255,0.08);
           border: 1px solid var(--glass-border);
           color: var(--text-main);
           font-size: 24px;
           width: 60px;
           height: 60px;
           border-radius: 12px;
           cursor: pointer;
           touch-action: manipulation;
           user-select: none;
           -webkit-user-select: none;
        }
        
        .mobile-btn:active {
          background: rgba(255,255,255,0.2);
          transform: scale(0.95);
        }
      }
    </style>
  </head>
  <body>
    <div id="mainContainer">
      <!-- Game Area -->
      <div id="gameContainer">
        <canvas id="canvas" width="640" height="480"></canvas>
        <div id="countdown"></div>
        <div id="victoryOverlay">
          <div id="victoryText">VICTORY</div>
          <button id="playAgainBtn">Play Again</button>
        </div>
      </div>
      
      <!-- Side/Control Panel -->
      <div id="sidePanel">
        <!-- Single Control Card -->
        <div class="panel-card">
          <div id="scoreRow">
            <div id="scoreContainer">
              <button id="mobileUp" class="mobile-btn">▲</button>
              <div id="score">0 : 0</div>
              <button id="mobileDown" class="mobile-btn">▼</button>
            </div>
            <div id="winCondition">First to 5 Wins</div>
          </div>
          
          <div id="metrics">
            <div class="metric-row">
              <span class="metric-label">FPS</span>
              <span class="metric-value" id="fps">--</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">PING</span>
              <span class="metric-value" id="ping">--</span>
              <span style="font-size: 10px; margin-left: 2px;">ms</span>
            </div>
          </div>
          
          <button id="playBtn" disabled>Play Now</button>
          
          <!-- Hidden input to store match code -->
          <input type="text" id="matchCode" maxlength="5" />
          
          <!-- Multiplayer: Create match button -->
          <div id="lobbyControls">
            <button id="createBtn" class="btn-challenge">Challenge a Friend</button>
          </div>
          
          <!-- Waiting for opponent -->
          <div id="activeMatchControls" style="display: none;">
            <div class="waiting-state">
              <div class="waiting-text">Waiting for opponent...</div>
              <div class="waiting-subtext">✓ Link copied to clipboard</div>
              <button id="leaveBtn" class="btn-leave">Cancel</button>
            </div>
          </div>
          
          <div class="controls-info">
            CONTROLS<br>
            W / S or ↑ / ↓ to Move
          </div>
        </div>
      </div>
    </div>

    <!-- JS Logic -->
    <script type="module">
      // Sound effects using Web Audio API
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      let audioCtx = null;

      function initAudio() {
        if (!audioCtx) {
          audioCtx = new AudioContext();
        }
      }

      function playSound(type) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        switch (type) {
          case "paddle":
            osc.frequency.setValueAtTime(440, audioCtx.currentTime);
            osc.type = "sine";
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
            break;
          case "wall":
            osc.frequency.setValueAtTime(220, audioCtx.currentTime);
            osc.type = "sine";
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.08);
            break;
          case "score":
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.2);
            osc.type = "triangle";
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
            break;
          case "victory":
            [0, 0.15, 0.3].forEach((delay, i) => {
              const o = audioCtx.createOscillator();
              const g = audioCtx.createGain();
              o.connect(g);
              g.connect(audioCtx.destination);
              o.frequency.setValueAtTime([523, 659, 784][i], audioCtx.currentTime + delay);
              o.type = "triangle";
              g.gain.setValueAtTime(0.1, audioCtx.currentTime + delay);
              g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + delay + 0.3);
              o.start(audioCtx.currentTime + delay);
              o.stop(audioCtx.currentTime + delay + 0.3);
            });
            break;
        }
      }

      const CACHE_BUST = new URLSearchParams(window.location.search).get("v") || Date.now();
      const wasmUrl = "/client_wasm/client_wasm.js?v=" + CACHE_BUST;

      let init, WasmClient;
      try {
        const module = await import(wasmUrl);
        init = module.default;
        WasmClient = module.WasmClient;
      } catch (error) {
        console.error("Failed to load WASM:", error);
        document.getElementById("status").textContent = "Failed to load game resource";
        throw error;
      }

      let client = null;
      let ws = null;
      let lastScore = [0, 0];
      let isPlaying = false;
      let victoryShown = false;
      let renderLoopId = null;
      let pingIntervalId = null;

      function updateStatus(msg) {
        // Show status in the play button when not actively playing
        const playBtn = document.getElementById("playBtn");
        if (playBtn && !playBtn.classList.contains("playing")) {
          playBtn.textContent = msg;
        }
      }

      function updateScore(left, right) {
        const el = document.getElementById("score");
        if (el) {
          if (left !== lastScore[0] || right !== lastScore[1]) {
            playSound("score");
            el.classList.add("flash");
            setTimeout(() => el.classList.remove("flash"), 200);
            lastScore = [left, right];
          }
          el.textContent = `${left} : ${right}`;
        }
      }

      function updateMetrics() {
        if (client) {
          try {
            const metrics = client.get_metrics();
            if (metrics.length >= 2) {
              document.getElementById("fps").textContent = Math.round(metrics[0]);
              document.getElementById("ping").textContent = Math.round(metrics[1]);
            }
          } catch (e) {}
        }
      }

      async function showCountdown() {
        const el = document.getElementById("countdown");
        for (const text of ["3", "2", "1", "GO!"]) {
          el.textContent = text;
          el.classList.add("show");
          playSound("paddle");
          await new Promise(r => setTimeout(r, 600));
          el.classList.remove("show");
          await new Promise(r => setTimeout(r, 100));
        }
      }

      function showVictory(winner) {
        // Prevent calling multiple times
        if (victoryShown) return;
        victoryShown = true;
        
        playSound("victory");
        const overlay = document.getElementById("victoryOverlay");
        const text = document.getElementById("victoryText");
        
        if (winner === "you") {
            text.textContent = "VICTORY";
            text.className = "status-win";
        } else {
            text.textContent = "DEFEAT";
            text.className = "status-lose";
        }
        
        overlay.classList.add("show");
        document.body.classList.remove("game-active");
      }

      function hideVictory() {
        document.getElementById("victoryOverlay").classList.remove("show");
        victoryShown = false;
        
        // Reset play button state
        const playBtn = document.getElementById("playBtn");
        playBtn.textContent = "Play Again";
        playBtn.classList.remove("playing");
        playBtn.disabled = false;
      }

      window.startLocalGame = async function () {
        try {
          initAudio();
          
          // Stop any existing game loop
          if (renderLoopId) {
            cancelAnimationFrame(renderLoopId);
            renderLoopId = null;
          }
          if (pingIntervalId) {
            clearInterval(pingIntervalId);
            pingIntervalId = null;
          }
          
          hideVictory();
          const playBtn = document.getElementById("playBtn");
          
          // Show starting state in button
          playBtn.textContent = "Starting...";
          playBtn.disabled = true;
          
          const canvas = document.getElementById("canvas");
          if (!client) {
            client = await new WasmClient(canvas);
          }
          await showCountdown();
          client.start_local_game();
          lastScore = [0, 0];
          updateScore(0, 0);
          
          // Update button to show active state
          playBtn.textContent = "Playing vs AI";
          playBtn.classList.add("playing");
          
          isPlaying = true;
          document.body.classList.add("game-active");
          setupInput();
          startRender();
        } catch (error) {
          updateStatus("Error: " + error.message);
        }
      };

      window.createMatch = async function () {
        try {
          initAudio();
          updateStatus("Creating match...");
          const response = await fetch("/create");
          const data = await response.json();
          document.getElementById("matchCode").value = data.code;
          
          // Build the invite URL
          const url = new URL(window.location);
          url.searchParams.set("code", data.code);
          const inviteUrl = url.toString();
          
          // Auto-copy to clipboard
          try {
            await navigator.clipboard.writeText(inviteUrl);
          } catch (clipErr) {
            console.warn("Could not copy to clipboard:", clipErr);
          }
          
          window.history.pushState({}, "", url);
          updateStatus(`Waiting for friend...`);
          await joinMatch();
        } catch (error) {
          updateStatus("Error creating match");
        }
      };

      window.joinMatch = async function () {
        const code = document.getElementById("matchCode").value.trim().toUpperCase();
        if (code.length !== 5) {
          updateStatus("Invalid code length");
          return;
        }
        try {
          initAudio();
          
          // Stop any existing game loops and WebSocket
          if (renderLoopId) {
            cancelAnimationFrame(renderLoopId);
            renderLoopId = null;
          }
          if (pingIntervalId) {
            clearInterval(pingIntervalId);
            pingIntervalId = null;
          }
          if (ws) {
            ws.close();
            ws = null;
          }
          isPlaying = false;
          victoryShown = false;
          
          hideVictory();
          updateStatus("Connecting...");
          const canvas = document.getElementById("canvas");
          if (!client) {
            client = await new WasmClient(canvas);
          }
          // Reset client state for clean multiplayer session
          client.reset_for_multiplayer();
          
          const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
          const wsUrl = `${protocol}//${window.location.host}/ws/${code}`;
          
          const url = new URL(window.location);
          if (url.searchParams.get("code") !== code) {
            url.searchParams.set("code", code);
            window.history.pushState({}, "", url);
          }
          
          document.getElementById("lobbyControls").style.display = "none";
          document.getElementById("activeMatchControls").style.display = "block";
          
          ws = new WebSocket(wsUrl);
          ws.binaryType = "arraybuffer";
          ws.onopen = async () => {
            try {
              ws.send(client.get_join_bytes(code));
              updateStatus("Waiting for opponent...");
            } catch (e) {
              console.error("Join error:", e);
            }
          };
          ws.onmessage = (event) => {
            if (event.data instanceof ArrayBuffer) {
              try {
                client.on_message(new Uint8Array(event.data));
                const score = client.get_score();
                if (score.length >= 2) {
                  updateScore(score[0], score[1]);
                }
                if (!isPlaying) {
                  isPlaying = true;
                  document.body.classList.add("game-active");
                  
                  // Update button to show match is active
                  const playBtn = document.getElementById("playBtn");
                  playBtn.textContent = "In Match";
                  playBtn.classList.add("playing");
                  
                  setupInput();
                  startRender();
                }
              } catch (e) {}
            }
          };
          ws.onerror = (error) => {
            updateStatus("Connection error");
          };
          ws.onclose = () => {
            isPlaying = false;
            document.body.classList.remove("game-active");
            
            // Reset button state
            const playBtn = document.getElementById("playBtn");
            playBtn.textContent = "Play Now";
            playBtn.classList.remove("playing");
            
            // Show lobby controls again
            document.getElementById("lobbyControls").style.display = "block";
            document.getElementById("activeMatchControls").style.display = "none";
            
            // Clear URL code
            const url = new URL(window.location);
            url.searchParams.delete("code");
            window.history.pushState({}, "", url);
            document.getElementById("matchCode").value = "";
            
            updateStatus("Disconnected");
          };
        } catch (error) {
          updateStatus("Error: " + error.message);
        }
      };

      function startRender() {
        function render() {
          if (client) {
            try {
              client.render();
              updateMetrics();
              const score = client.get_score();
              if (score.length >= 2) {
                updateScore(score[0], score[1]);
                const winner = client.get_winner();
                if (winner) {
                  showVictory(winner);
                  isPlaying = false;
                  return;
                }
                if (score[0] >= 5 || score[1] >= 5) {
                  const winnerName = score[0] >= 5 ? "you" : "opponent";
                  showVictory(winnerName);
                  isPlaying = false;
                  return; 
                }
              }
            } catch (e) {}
          }
          if (isPlaying) {
            renderLoopId = requestAnimationFrame(render);
          }
        }
        render();

        pingIntervalId = setInterval(() => {
          if (ws && ws.readyState === WebSocket.OPEN && client) {
            try {
              const pingBytes = client.send_ping();
              ws.send(pingBytes);
            } catch (e) {}
          }
        }, 2000);
      }

      function sendInput() {
        if (ws && ws.readyState === WebSocket.OPEN && client) {
          try {
            const bytes = client.get_input_bytes();
            if (bytes.length > 0) {
              ws.send(bytes);
            }
          } catch (e) {}
        }
      }

      function setupInput() {
        const pressedKeys = new Set();
        window.addEventListener("keydown", (e) => {
          const gameKeys = ["ArrowUp", "ArrowDown", "w", "W", "s", "S"];
          if (gameKeys.includes(e.key)) {
            e.preventDefault();
            const upKeys = ["ArrowUp", "w", "W"];
            const downKeys = ["ArrowDown", "s", "S"];
            if (upKeys.includes(e.key)) {
              downKeys.forEach(key => {
                if (pressedKeys.has(key)) {
                  pressedKeys.delete(key);
                  if (client) client.handle_key_string(key, false);
                }
              });
              pressedKeys.add(e.key);
            } else if (downKeys.includes(e.key)) {
              upKeys.forEach(key => {
                if (pressedKeys.has(key)) {
                  pressedKeys.delete(key);
                  if (client) client.handle_key_string(key, false);
                }
              });
              pressedKeys.add(e.key);
            }
          }
          if (client) {
            client.on_key_down(e);
            sendInput();
          }
        }, { capture: true, passive: false });

        window.addEventListener("keyup", (e) => {
          const gameKeys = ["ArrowUp", "ArrowDown", "w", "W", "s", "S"];
          if (gameKeys.includes(e.key)) {
            e.preventDefault();
            pressedKeys.delete(e.key);
          }
          if (client) {
            client.on_key_up(e);
            sendInput();
          }
        }, { capture: true, passive: false });

        const mobileUp = document.getElementById("mobileUp");
        const mobileDown = document.getElementById("mobileDown");

        const setupTouch = (info) => {
             const btn = info.btn;
             const key = info.key;
             if (!btn) return;
             const handle = (e, isDown) => {
                 if (e.type !== 'click') e.preventDefault();
                 if (client) {
                     client.handle_key_string(key, isDown);
                     sendInput();
                 }
             };
             btn.addEventListener("touchstart", (e) => handle(e, true));
             btn.addEventListener("touchend", (e) => handle(e, false));
             btn.addEventListener("mousedown", (e) => handle(e, true));
             btn.addEventListener("mouseup", (e) => handle(e, false));
             btn.addEventListener("mouseleave", (e) => handle(e, false));
        };
        setupTouch({btn: mobileUp, key: "ArrowUp"});
        setupTouch({btn: mobileDown, key: "ArrowDown"});
        setInterval(sendInput, 33);
      }

      // Multiplayer toggle removed - section is always visible

      document.getElementById("playAgainBtn").addEventListener("click", () => {
        hideVictory();
        window.startLocalGame();
      });

      // Copy link button removed - link is auto-copied on match creation

      document.getElementById("leaveBtn").addEventListener("click", () => {
        if (ws) ws.close();
        document.getElementById("lobbyControls").style.display = "block";
        document.getElementById("activeMatchControls").style.display = "none";
        
        const url = new URL(window.location);
        url.searchParams.delete("code");
        window.history.pushState({}, "", url);
        document.getElementById("matchCode").value = "";
        updateStatus("Left match");
      });

      async function main() {
        try {
          await init();
          updateStatus("Ready to Play");
          document.getElementById("playBtn").disabled = false;
          document.getElementById("playBtn").addEventListener("click", window.startLocalGame);
          document.getElementById("createBtn").addEventListener("click", window.createMatch);

          // Auto-join if code in URL (from invite link)
          const urlParams = new URLSearchParams(window.location.search);
          const code = urlParams.get("code");
          if (code) {
             document.getElementById("matchCode").value = code;
             updateStatus("Joining game...");
             await window.joinMatch();
          }
        } catch (error) {
          updateStatus("Error: " + error.message);
        }
      }

      main().catch((error) => {
        document.getElementById("status").textContent = "Fatal error: " + error.message;
      });
    </script>
  </body>
</html>
