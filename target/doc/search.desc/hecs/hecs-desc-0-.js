searchState.loadedDescShard("hecs", 0, "A handy ECS\nType of access a <code>Query</code> may have to an <code>Archetype</code>\nA collection of entities having the same component types\nShared reference to a single column of component data in …\nUnique reference to a single column of component data in …\nDetermines freshness of information derived from …\nA sequence of entities yielded by <code>BatchedIter</code>\nError indicating that a <code>ColumnBatchBuilder</code> was missing …\nHandle for appending components\nBatched version of <code>QueryIter</code>\nBoth an <code>L</code> and an <code>R</code>\nThe output of an <code>EntityBuilder</code>, suitable for passing to …\nA collection of components that implement <code>Clone</code>\nA statically typed collection of components\nHelper to track changes in <code>T</code> components\nCollection of iterators over changes in <code>T</code> components\nA collection of component data for entities with the same …\nAn incomplete collection of component data for entities …\nA collection of component types\nRecords operations for future application to a <code>World</code>\nTypes that can be components, implemented automatically …\nErrors that arise when accessing components\n<code>&amp;T</code> or <code>&amp;mut T</code> where <code>T</code> is some component type\n<code>&amp;T</code> where <code>T</code> is some component type\nAn <code>Entity</code> that does not necessarily correspond to data in …\nA dynamically typed collection of components\nA dynamically typed collection of cloneable components\nLightweight unique ID, or handle, of an entity\nHelper for incrementally constructing a bundle of …\nVariant of <code>EntityBuilder</code> that clones components on use\nHandle to an entity with any component types\nType of results yielded by the query\nIterator over all of a world’s entities\nRead entity IDs only, no components\nJust an <code>L</code>\nError indicating that an entity did not have a required …\nThe entity did not have a requested component\nError indicating that no entity with a particular ID exists\nThe entity was already despawned\nThe entity was already despawned\nHolds an <code>L</code>, or an <code>R</code>, or both\nA prepared query can be stored independently of the <code>World</code> …\nCombined borrow of a <code>PreparedQuery</code> and a <code>World</code>\nIterates over all entities matching a <code>PreparedQuery</code>\nProvides random access to the results of a prepared query\nA collection of component types to fetch from a <code>World</code>\nA borrow of a <code>World</code> sufficient to execute the query <code>Q</code>\nIterator over the set of entities with the components in <code>Q</code>\nA query builder that’s convertible directly into an …\nA borrow of a <code>World</code> sufficient to execute the query <code>Q</code> on a …\nErrors that arise when querying a single entity\nMarker trait indicating whether a given <code>Query</code> will not …\nRead components\nShared borrow of an entity’s component\nUnique borrow of an entity’s component\nJust an <code>R</code>\nA query that matches all entities, yielding <code>bool</code>s …\nEntity IDs created by <code>World::spawn_batch</code>\nIterator over <code>Entity</code>s spawned by …\nAn entity removed from a <code>World</code>\nThe entity exists but does not satisfy the query\nProvides random access to the results of a query\nA borrow of a <code>World</code> sufficient to random-access the …\nTransforms query <code>Q</code> by skipping entities not satisfying …\nTransforms query <code>Q</code> by skipping entities satisfying query <code>R</code>\nAn unordered collection of entities, each having any …\nRead and write components\nHow, if at all, <code>Q</code> will access entities in this archetype\nUpdate to include <code>T</code> components\nAdd <code>component</code> to the entity.\nAdd <code>component</code> to the entity.\nAdd all components in <code>bundle</code> to the entity.\nAdd all components in <code>bundle</code> to the entity.\nIterate over entities which were given a new <code>T</code> component …\nInspect the archetypes that entities are organized into\nReturns a distinct value after <code>archetypes</code> is changed\nConvert from <code>&amp;mut Or&lt;L, R&gt;</code> to <code>Or&lt;&amp;mut L, &amp;mut R&gt;</code>\nConvert from <code>&amp;Or&lt;L, R&gt;</code> to <code>Or&lt;&amp;L, &amp;R&gt;</code>\nFinish the batch, failing if any components are missing\nConstruct a <code>Bundle</code> suitable for spawning\nConvert into a value whose shared references are …\nChecks if a query is satisfied by a bundle. This is …\nIterate over <code>(entity, old, new)</code> for entities whose <code>T</code> …\nDrop all recorded commands\nDespawn all entities\nDrop previously <code>add</code>ed components\nDrop previously <code>add</code>ed components\nMaps an <code>Or&lt;&amp;L, &amp;R&gt;</code> to an <code>Or&lt;L, R&gt;</code> by cloning its contents\nEnumerate the types of the components of entities stored …\nEnumerate the types of the entity builder’s components\nEnumerate the types of the entity builder’s components\nEnumerate the types of the entity’s components\nEquivalent to <code>get(entity).is_some()</code>, but does not require …\nEquivalent to <code>get(entity).is_some()</code>, but does not require …\nEquivalent to <code>get(entity).is_some()</code>, but does not require …\nWhether <code>entity</code> still exists\nCreate an empty buffer\nDespawn <code>entity</code> from World\nDestroy an entity and all its components\nChecks if a query is satisfied by a dynamic bundle. For …\nAccess an entity regardless of its component types\nGet the <code>Entity</code> handle associated with this entity\nRemove <code>S</code> components from <code>entity</code> and then add <code>components</code>\nRemove the <code>S</code> component from <code>entity</code> and then add <code>component</code>\nHow many components have been added so far\nGiven an id obtained from <code>Entity::id</code>, reconstruct the …\nConvert all reserved entities into empty entities that can …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReconstruct an <code>Entity</code> previously destructured with <code>to_bits</code> …\nBorrow all components of a single type from these …\nRetrieve the query results corresponding to <code>entity</code>\nRetrieve the query results corresponding to <code>entity</code>\nRetrieve the query results corresponding to <code>entity</code>\nGet the query result, or <code>None</code> if the entity does not …\nShort-hand for <code>entity</code> followed by <code>EntityRef::get</code>\nBorrow a shared reference <code>T</code> to some component type, if it …\nBorrow a shared reference <code>T</code> to some component type, if it …\nBorrow a single component, if it exists\nLike <code>get_mut</code>, but allows checked simultaneous access to …\nLike <code>get_mut</code>, but allows checked simultaneous access to …\nLike <code>get_mut</code>, but allows checked simultaneous access to …\nRetrieve the query results corresponding to <code>entity</code>\nRetrieve the query results corresponding to <code>entity</code>\nRetrieve the query results corresponding to <code>entity</code>\nBorrow a shared or unique reference <code>T</code> to some component …\nBorrow a shared or unique reference <code>T</code> to some component …\nLike <code>get_mut</code>, but allows simultaneous access to multiple …\nLike <code>get_mut</code>, but allows simultaneous access to multiple …\nLike <code>get_mut</code>, but allows simultaneous access to multiple …\nBorrow a single component of <code>entity</code> without safety checks\nWhether this archetype contains <code>T</code> components\nChecks if the Bundle contains the given <code>T</code>:\nChecks if the Bundle contains the given <code>T</code>:\nChecks to see if the component of type <code>T</code> exists\nChecks to see if the component of type <code>T</code> exists\nDetermine whether this entity has a <code>T</code> component without …\nWhether this archetype contains components with the type …\nExtract a transiently unique identifier\nRaw IDs of the entities in this archetype\nAdd components from <code>bundle</code> to <code>entity</code>, if it exists\nAdd <code>components</code> to <code>entity</code>\nAdd <code>component</code> to <code>entity</code>, if the entity exists\nAdd <code>component</code> to <code>entity</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a <code>ColumnBatchBuilder</code> for <em>exactly</em> <code>size</code> entities …\nLike <code>into_iter</code>, but returns child iterators of at most …\nWhether this archetype contains no entities\nWhether no entities are live\nShorthand for <code>self.len() == 0</code>\nExecute the query\nExecute the prepared query\nIterate over all entities in the world\nLike <code>iter</code>, but returns child iterators of at most …\nIterate over all entities satisfying <code>Q</code>\nIterate over all entities satisfying <code>Q</code>\nIterate over all entities satisfying <code>Q</code>\nExtract <code>L</code> regardless of whether <code>R</code> is present\nNumber of entities in this archetype\nNumber of currently live entities\nNumber of components in this entity\nTransform the <code>Ref&lt;&#39;_, T&gt;</code> to point to a part of the …\nTransform the <code>RefMut&lt;&#39;_, T&gt;</code> to point to a part of the …\nTransform <code>L</code> with <code>f</code> and <code>R</code> with <code>g</code>\nCreate a batch for <em>exactly</em> <code>size</code> entities with certain …\nCreate a change tracker for <code>T</code> components\nCreate an empty command buffer\nCreate a prepared query which is not yet attached to any …\nCreate an empty world\nCreate an empty type\nConstruct an error representing a missing <code>T</code>\nCreate a builder representing an entity with no components\nCreate a builder representing an entity with no components\nConstruct an <code>Or&lt;L, R&gt;</code> if at least one argument is <code>Some</code>\nAdd a component if there’s space remaining\nQuery <code>world</code>, using dynamic borrow checking\nEfficiently iterate over all entities that have certain …\nRun a query against this entity\nQuery a fixed number of distinct entities in a uniquely …\nQuery a uniquely borrowed world\nQuery a uniquely borrowed world\nPrepare a query against a single entity, using dynamic …\nQuery a single entity in a uniquely borrowed world\nRemove components from <code>entity</code> if they exist\nRemove components from <code>entity</code>\nRemove a component from <code>entity</code> if it exists\nRemove the <code>T</code> component from <code>entity</code>\nIterate over entities which lost their <code>T</code> component after …\nEnsure at least <code>additional</code> entities with exact components <code>T</code>…\nAllocate many entities ID concurrently\nAllocate an entity ID concurrently\nExtract <code>R</code> regardless of whether <code>L</code> is present\nRun recorded commands on <code>world</code>, clearing the command buffer\nDetermine whether this archetype would satisfy the query <code>Q</code>\nShort-hand for <code>entity</code> followed by <code>EntityRef::satisfies</code>\nDetermine whether this entity would satisfy the query <code>Q</code> …\nSpawn a new entity with <code>components</code>\nCreate an entity with certain components\nCreate an entity with certain components and a specific …\nEfficiently spawn a large number of entities with the same …\nSuper-efficiently spawn the contents of a <code>ColumnBatch</code>\nHybrid of <code>spawn_column_batch</code> and <code>spawn_at</code>\nDestructure into two <code>Option</code>s, where either or both are <code>Some</code>\nDespawn <code>entity</code>, yielding a <code>DynamicBundle</code> of its components\nConvert to a form convenient for passing outside of rust\nDetermine the changes in <code>T</code> components in <code>world</code> since the …\nProvide random access to the query results\nProvide random access to the query results\nProvides random access to the results of the prepared query\nProvide random access to any entity for a given Query.\nProvide random access to query results for a uniquely …\nProvide random access to any entity for a given Query on a …\nTransform the query into one that requires another query …\nTransform the query into one that requires another query …\nTransform the query into one that requires another query …\nTransform the query into one that skips entities …\nTransform the query into one that skips entities …\nTransform the query into one that skips entities …\nGet a handle for inserting <code>T</code> components if <code>T</code> was in the …")